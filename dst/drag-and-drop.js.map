{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/action.js","drag-and-drop.js","src/component.js","src/container.js","src/dragAndDropSystem.js","src/draggable_element.js","src/main.js","src/utils.js"],"names":["r","e","n","t","o","i","f","c","require","u","a","Error","code","p","exports","call","length","1","module","action","dstCont","dstPos","dropType","Action","this","sameAs","other","2","component","elem","constructor","Component","element","paper","Element","groupNode","Array","cx","cy","opacity","raphael","el","vml","document","createElement","style","position","createElementNS","canvas","appendChild","group","self","transform","placeAt","alert","addElement","utils","prototype","type","j","node","bb","getBBox","overlay","rect","x","y","width","height","attr","clone","left","top","placeAtWithAnim","time","animate","remove","show","hide","halfHide","drag","moveDrag","startDrag","upDrag","undrag","toFront","ie6","./utils","3","container","dragAndDropSystem","params","isUndefined","ident","notIn","widthPlace","heightPlace","align","direction","dragDisplayMode","placeBackgroundArray","w","h","dropMode","nbPlaces","sourceElemArray","set","Container","places","sanityCheck","placeHolder","stroke","stroke-width","stroke-dasharray","indicator","template","iPlace","placeCenter","draggableElements","center","sourceComponent","window","sourceComponents","push","draggableElement","updateSource","draggable","timeAnim","DraggableElement","placeId","isInContainer","ratioPositionInPlace","c0","c1","c0p","c0c1","prodScal","posAbs","parseFloat","getCorrespondingAction","pos","ratio","getElementsAfterDrop","srcCont","srcPos","res","end","createAt","centerPosition","clearPlace","clear","elems","getObjects","setObjects","objects","object","getElementOver","srcEl","showIndicator","act","prevC","hideIndicator","updateDisplay","updateIntermediateDisplay","intermed","iPlaceIns","cross","./action","./component","./draggable_element","4","DragAndDropSystem","overridable","prop","keepLastGoodAction","containers","lastDisplayedAction","lastOver","hasOwnProperty","addContainer","heigthPlace","dragDiplayMode","newContainer","removeContainer","cont","pop","getContainer","containerIdent","iCont","insertObject","elements","insertObjects","removeObject","removeAllObjects","userActionToAction","actUser","actionIfDropped","hideIndicators","hasBeenTaken","hasBeenMoved","disabled","elOver","over","hasBeenDropped","handleDrop","newObjects","iDstCont","ejected","elPastEnd","refEl","previousCont","previousPos","drop","handleEjection","actionIfEjected","canBeTaken","containerId","srcContId","dstContId","disable","./container","5","dragState","crossShape","initDrag","comp","_moveDragCallback","_startDragCallback","_endDragCallback","dragNotEnded","ox","oy","hasReallyMoved","dx","dy","state","isNaN","Math","abs","6","./dragAndDropSystem","7","test","navigator","userAgent","parseInt","RegExp","$1","val"],"mappings":"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","file":"drag-and-drop.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","'use strict';\r\n\r\n/*\r\n  Une action correspond à ce qui peut se passer un draggable objet\r\n  si on le lache. Elle indique où l'objet doit être envoyé (dstCont est\r\n  l'id du container destination, et dstPos et l'indice de la position\r\n  dans le container).\r\n  dropType peut valoir : \"replace\" ou \"insert\"\r\n  et expliquer comment l'objet doit être mis dans le container destination\r\n  (dans le cas où l'action est bien réalisée).\r\n*/\r\n\r\nmodule.exports = action;\r\n\r\nfunction action (dstCont, dstPos, dropType) {\r\n    return new Action(dstCont, dstPos, dropType);\r\n}\r\n\r\nfunction Action (dstCont, dstPos, dropType) {\r\n    this.dstCont = dstCont;\r\n    this.dstPos = dstPos;\r\n    this.dropType = dropType;\r\n\r\n    this.sameAs = function (other) {\r\n        return this.dstCont === other.dstCont && this.dstPos === other.dstPos && this.dropType === other.dropType;\r\n    };\r\n}\r\n","(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n'use strict';\r\n\r\n/*\r\n  Une action correspond à ce qui peut se passer un draggable objet\r\n  si on le lache. Elle indique où l'objet doit être envoyé (dstCont est\r\n  l'id du container destination, et dstPos et l'indice de la position\r\n  dans le container).\r\n  dropType peut valoir : \"replace\" ou \"insert\"\r\n  et expliquer comment l'objet doit être mis dans le container destination\r\n  (dans le cas où l'action est bien réalisée).\r\n*/\r\n\r\nmodule.exports = action;\r\n\r\nfunction action (dstCont, dstPos, dropType) {\r\n    return new Action(dstCont, dstPos, dropType);\r\n}\r\n\r\nfunction Action (dstCont, dstPos, dropType) {\r\n    this.dstCont = dstCont;\r\n    this.dstPos = dstPos;\r\n    this.dropType = dropType;\r\n\r\n    this.sameAs = function (other) {\r\n        return this.dstCont === other.dstCont && this.dstPos === other.dstPos && this.dropType === other.dropType;\r\n    };\r\n}\r\n\n},{}],2:[function(require,module,exports){\n'use strict';\r\n\r\n// A Component is a wrapper around a single Raphael element (which can be\r\n// a set) that allows setting the position the element.\r\n// The implementation relies on the Raphael group extension to move many\r\n// elements as one, which is required in particular for IE6 (which otherwise\r\n// moves elements individually, partially redrawing the canvas between moves).\r\n\r\n/*\r\n  Outdated comment:\r\n\r\n  Component : Permet de manipuler un objet graphique composé de plusieurs\r\n  petits objets Raphael, donnés dans le tableau arrayElems. Ces sous-objets\r\n  doivent être donnés en coordonnées relatives : si un objet du tableau est\r\n  un objet Raphael centré en (10,20) alors il apparaitra en (cx+10,cy+20),\r\n  (cx,cy) étant le centre du super-objet.\r\n  Notamment, on peut faire:\r\n  - des déplacements, ce qui déplace ensemble tous les sous-objets.\r\n  - du drag&drop, en propageant les fonctions callbacks à tous  les\r\n    sous-objets, de sorte que lorsqu'un des sous-objets et déplacés,\r\n    tous les autres subissent le même déplacement. Ainsi on voit\r\n    tous les objets bouger ensemble, comme si c'était un seul gros objet.\r\n*/\r\n\r\nvar utils = require('./utils');\r\n\r\nmodule.exports = component;\r\n\r\nfunction component (elem) {\r\n    // If a component is passed, return it unchanged.\r\n    if (elem.constructor === Component)\r\n        return elem;\r\n    return new Component(elem);\r\n}\r\n\r\nfunction Component (element) {\r\n    var paper, Element, groupNode;\r\n    if (element instanceof Array)\r\n        throw \"A Raphael element is required\";\r\n    this.element = element;\r\n    this.cx = 0;\r\n    this.cy = 0;\r\n    this.opacity = 1;\r\n    paper = this.paper = element.paper;\r\n    // Retrieve the Raphael Element constructor.\r\n    Element = paper.raphael.el.constructor;\r\n    // Create a group VML or SVG node.\r\n    if (paper.raphael.vml) {\r\n        this.vml = true;\r\n        groupNode = document.createElement(\"group\");\r\n        groupNode.style.position = 'absolute';\r\n    } else {\r\n        this.vml = false;\r\n        groupNode = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\r\n    }\r\n    // Add the group node to the canvas.\r\n    paper.canvas.appendChild(groupNode);\r\n    // Wrap a Raphael element around the group node; this is not directly\r\n    // supported by Raphael, but it works for all our use cases.\r\n    this.group = new Element(groupNode, paper);\r\n    if (this.vml) {\r\n        // VML only fix: allow applying a pure translation transform to the group.\r\n        var self = this;\r\n        this.group.transform = function (t) {\r\n            if (typeof t === 'undefined')\r\n                return [['t', self.cx, self.cy]];\r\n            if (t.length === 1 && t[0][0] === 't') {\r\n                self.placeAt(t[0][1], t[0][2]);\r\n                return;\r\n            }\r\n            alert('unsupported VML group transform');\r\n        }\r\n    }\r\n    // Move the element's DOM nodes (recursing into Raphael sets) inside the\r\n    // group node.\r\n    this.addElement(element);\r\n}\r\n\r\nComponent.prototype.addElement = function (element) {\r\n    if (element.type === 'set') {\r\n        for (var i = 0, j = element.length; i < j; i++) {\r\n            this.addElement(element[i]);\r\n        }\r\n    } else {\r\n        this.group.node.appendChild(element.node);\r\n        if (!this.vml && element.type === 'text') {\r\n            // When using SVG, overlay a transparent rect over text elements to\r\n            // prevent user interaction with the text (cursor change, selection).\r\n            var bb = element.getBBox();\r\n            var overlay = this.paper.rect(bb.x,bb.y,bb.width,bb.height).attr('fill','red').attr('opacity',0);\r\n            this.group.node.appendChild(overlay.node);\r\n        }\r\n    }\r\n};\r\n\r\nComponent.prototype.clone = function () {\r\n    var clone = new Component(this.element.clone());\r\n    clone.placeAt(this.cx, this.cy);\r\n    return clone;\r\n};\r\n\r\nComponent.prototype.placeAt = function (cx, cy) {\r\n    this.cx = cx;\r\n    this.cy = cy;\r\n    if (this.vml) {\r\n        this.group.node.style.left = cx + 'px';\r\n        this.group.node.style.top = cy + 'px';\r\n    } else {\r\n        this.group.transform('t' + cx + ',' + cy);\r\n    }\r\n    return this;\r\n};\r\n\r\nComponent.prototype.placeAtWithAnim = function (cx, cy, time) {\r\n    this.cx = cx;\r\n    this.cy = cy;\r\n    this.group.animate({\r\n        transform: 't' + cx + ',' + cy\r\n    }, time, '');\r\n    return this;\r\n};\r\n\r\nComponent.prototype.remove = function () {\r\n    // Removing the group will remove the nested element.\r\n    this.group.remove();\r\n};\r\n\r\nComponent.prototype.show = function () {\r\n    if (this.opacity !== 1) {\r\n        this.group.attr('opacity', 1);\r\n        this.opacity = 1;\r\n    }\r\n    this.group.show();\r\n    return this;\r\n};\r\n\r\nComponent.prototype.hide = function () {\r\n    this.group.hide();\r\n    return this;\r\n};\r\n\r\nComponent.prototype.halfHide = function () {\r\n    this.group.attr('opacity', 0.3);\r\n    this.opacity = 0.3;\r\n    return this;\r\n};\r\n\r\nComponent.prototype.drag = function (moveDrag, startDrag, upDrag) {\r\n    this.group.drag(moveDrag, startDrag, upDrag);\r\n    return this;\r\n};\r\n\r\nComponent.prototype.undrag = function(){\r\n    this.group.undrag()\r\n    return this\r\n};\r\n\r\nComponent.prototype.toFront = function () {\r\n    this.group.toFront();\r\n    return this;\r\n};\r\n\r\nif (utils.ie6) {\r\n    // Disable animations, IE6 would animate from (0,0) to the new position,\r\n    // rather than from the old position to the new one.\r\n    Component.prototype.placeAtWithAnim = Component.prototype.placeAt;\r\n}\r\n\n},{\"./utils\":7}],3:[function(require,module,exports){\n'use strict';\r\n\r\n/*\r\n  Un container est un ensemble de cases (aliginées verticalement ou horizontalement). On peut lui donner\r\n  beaucoup de paramêtre pour spécifier son comportement.\r\n  direction : doit valoir \"vertical\" ou \"horizontal\"\r\n  align : dans le cas vertical, peut valoir \"left\" pour indiquer que la première case est à gauche, ou \"right\"\r\n          pour indiquer que la première case est à droite. Dans le cas vertical, peut valoir \"top\" ou \"bottom\".\r\n  cx, cy : donne le centre de la case la plus haute (pour le vertical) ou la plus a gauche (pour le cas horizontal)\r\n  dropMode :\r\n     - \"replace\" : lorsqu'un objet est laché sur une case, la case détruit son éventuel objet courant pour recevoir le nouveau.\r\n     - \"insert\"  : lorsqu'un objet est laché sur la case, l'objet actuel de la case (s'il y en a un) est décalé vers la droite,\r\n                   entrainant éventuellement un autre décalage et ainsi de suite... il peut y avoir une suppression\r\n                   si le dernier objet se fait éjecter du container.\r\n     - \"insert-replace\" : lorsqu'on lache l'objet, s'il est vers le début de la case, alors on a un comportement insert,\r\n                          sinon un comportement replace.\r\n     - \"insertBefore\" : comme insert, mais la zone de drop est plus du coté du début de la case, donc ca marche mieux\r\n                        avec dragDisplayMode=\"marker\".\r\n  dragDisplayMode : peut valoir \"preview\" (pour voir le placeholder avec des tirés jaune)\r\n                    ou \"marker\" (pour voir le trait rouge).\r\n  placeBackgroundArray : définit le background que l'on met à chaque case (juste pour faire joli).\r\n  type : peut valoir \"list\", pour un container classique, ou \"source\" le container peut recréer des objets\r\n         quand on lui prend le sien.\r\n  sourceElemArray : Utile seulement dans le cas type=\"source\", définit l'objet source à dupliquer.\r\n*/\r\n\r\nvar utils = require('./utils'),\r\n    component = require('./component'),\r\n    DraggableElement = require('./draggable_element'),\r\n    action = require('./action'),\r\n    isUndefined = utils.isUndefined,\r\n    notIn = utils.notIn;\r\n\r\nmodule.exports = container;\r\n\r\nfunction container (dragAndDropSystem, params) {\r\n    var paper = dragAndDropSystem.paper;\r\n\r\n    if (isUndefined(params.ident))\r\n        params.ident = '';\r\n    if (isUndefined(params.type))\r\n        params.type = 'list';\r\n    if (notIn(params.type, ['source', 'list']))\r\n        alert('type should be \\'source\\' or \\'list\\'');\r\n\r\n    if (isUndefined(params.cx) || isUndefined(params.cy))\r\n        alert('cx and cy are not specified');\r\n\r\n    if (isUndefined(params.widthPlace))\r\n        params.widthPlace = 40;\r\n    if (isUndefined(params.heightPlace))\r\n        params.heightPlace = 40;\r\n\r\n    if (!isUndefined(params.align)) {\r\n        if (notIn(params.align, ['top', 'bottom', 'left', 'right']))\r\n            alert('align should be \\'top\\' or \\'bottom\\' or \\'left\\' or \\'right\\'');\r\n        if (params.align === 'top' || params.align === 'bottom')\r\n            params.direction = 'vertical';\r\n        else\r\n            params.direction = 'horizontal';\r\n    } else {\r\n        if (isUndefined(params.direction)) {\r\n            params.direction = 'horizontal';\r\n            params.align = 'left';\r\n        } else {\r\n            if (params.direction === 'vertical')\r\n                params.align = 'top';\r\n            else if (params.direction === 'horizontal')\r\n                params.align = 'left';\r\n            else\r\n                alert('direction should be \\'vertical\\' or \\'horizontal\\' ');\r\n        }\r\n    }\r\n\r\n    if (isUndefined(params.dragDisplayMode))\r\n        params.dragDisplayMode = 'preview';\r\n    else if (notIn(params.dragDisplayMode, ['preview', 'marker']))\r\n        alert('dragDisplayMode should be \\'preview\\' or \\'marker\\' ');\r\n\r\n    if (isUndefined(params.placeBackgroundArray)) {\r\n        var w = params.widthPlace,\r\n            h = params.heightPlace;\r\n        params.placeBackgroundArray = [paper.rect(-w / 2, -h / 2, w, h).attr('fill', 'blue')];\r\n    }\r\n\r\n    if (params.type === 'source') {\r\n        if (isUndefined(params.dropMode))\r\n            params.dropMode = 'replace';\r\n        params.nbPlaces = 1;\r\n        if (isUndefined(params.sourceElemArray))\r\n            alert('sourceElemArray should be defined');\r\n        if (params.sourceElemArray instanceof Array)\r\n            params.sourceElemArray = paper.set(params.sourceElemArray);\r\n    }\r\n\r\n    if (params.type === 'list') {\r\n        if (isUndefined(params.dropMode))\r\n            params.dropMode = 'insert';\r\n        if (isUndefined(params.nbPlaces))\r\n            params.nbPlaces = 5;\r\n    }\r\n\r\n    return new Container(\r\n        dragAndDropSystem, params.ident,\r\n        params.cx, params.cy, params.nbPlaces, params.widthPlace, params.heightPlace,\r\n        params.direction, params.align,\r\n        params.dropMode, params.dragDisplayMode,\r\n        params.placeBackgroundArray, params.type, params.sourceElemArray, params.places);\r\n\r\n}\r\n\r\nfunction Container (\r\n    dragAndDropSystem, ident, cx, cy, nbPlaces, widthPlace, heightPlace,\r\n    direction, align, dropMode, dragDisplayMode, placeBackgroundArray,\r\n    type, sourceElemArray, places) {\r\n\r\n    this.dragAndDropSystem = dragAndDropSystem;\r\n    this.ident = ident;\r\n    this.cx = cx;\r\n    this.cy = cy;\r\n    this.nbPlaces = nbPlaces;\r\n    this.widthPlace = widthPlace;\r\n    this.heightPlace = heightPlace;\r\n    this.direction = direction;\r\n    this.align = align;\r\n    this.dropMode = dropMode;\r\n    this.dragDisplayMode = dragDisplayMode;\r\n    this.type = type;\r\n    this.places = places;\r\n\r\n    this.sanityCheck();\r\n\r\n    this.placeHolder = component(\r\n        dragAndDropSystem.paper.rect(-widthPlace / 2, -heightPlace / 2, widthPlace, heightPlace)\r\n        .attr({\r\n            'stroke': 'yellow',\r\n            'stroke-width': '2',\r\n            'stroke-dasharray': '-'\r\n        }));\r\n    this.placeHolder.hide();\r\n\r\n    this.indicator = null;\r\n\r\n    //Draw places\r\n    if (placeBackgroundArray) {\r\n        var template = dragAndDropSystem.paper.set(placeBackgroundArray);\r\n        for (var iPlace = 0; iPlace < this.nbPlaces; iPlace++) {\r\n            var c = this.placeCenter(iPlace);\r\n            component(template.clone()).placeAt(c[0], c[1]);\r\n        }\r\n        template.hide();\r\n    }\r\n\r\n    // Initialize the places.\r\n    this.draggableElements = [];\r\n    for (var i = 0; i < this.nbPlaces; i++)\r\n        this.draggableElements[i] = null;\r\n\r\n    if (this.type === 'source' && sourceElemArray) {\r\n        // Make a background component, which is also used to refill the source.\r\n        var center = this.placeCenter(0);\r\n        this.sourceComponent = component(sourceElemArray);\r\n        window.sourceComponents = (window.sourceComponents || []);\r\n        window.sourceComponents.push(this.sourceComponent);\r\n        this.sourceComponent.placeAt(center[0], center[1]);\r\n        // Fill the source with a draggable element.\r\n        var draggableElement = this.updateSource();\r\n        this.sourceComponent.draggable = draggableElement;\r\n    }\r\n\r\n    this.timeAnim = 100;\r\n}\r\n\r\nContainer.prototype.sanityCheck = function () {\r\n    if (notIn(this.direction, ['vertical', 'horizontal']))\r\n        alert('direction should be \\'vertical\\' or \\'horizontal\\'!');\r\n\r\n    if (this.direction === 'vertical')\r\n        if (notIn(this.align, ['top', 'bottom']))\r\n            alert('Since direction is vertical, align should be \\'top\\' or \\'bottom\\'');\r\n    if (this.direction === 'horizontal')\r\n        if (notIn(this.align, ['left', 'right']))\r\n            alert('Since direction is horizontal, align should be \\'left\\' or \\'right\\'');\r\n\r\n    if (notIn(this.dropMode, ['replace', 'insert-replace', 'insert', 'insertBefore']))\r\n        alert('dropMode should be \\'replace\\' or \\'insert\\' or \\'insert-replace\\' or \\'insertBefore\\'');\r\n\r\n    if (notIn(this.dragDisplayMode, ['preview', 'marker']))\r\n        alert('dragDisplayMode should be \\'preview\\' or \\'marker\\' ');\r\n\r\n    if (notIn(this.type, ['list', 'source']))\r\n        alert('type should be \\'list\\' or \\'source\\'');\r\n};\r\n\r\n/*\r\n  Fonction utilitaire : retourne les coordonnées du centre de la\r\n  case à l'indice iPlace.\r\n*/\r\nContainer.prototype.placeCenter = function (iPlace) {\r\n    var w = this.widthPlace,\r\n        h = this.heightPlace;\r\n    if (!isUndefined(this.places))\r\n        return this.places[iPlace];\r\n    if (this.direction === 'horizontal') {\r\n        if (this.align === 'left')\r\n            return [this.cx + ((2 * iPlace + 1 - this.nbPlaces) * w) / 2, this.cy];\r\n        else\r\n            return [this.cx + ((this.nbPlaces - 2 * iPlace - 1) * w) / 2, this.cy];\r\n    } else {\r\n        if (this.align === 'top')\r\n            return [this.cx, this.cy + ((2 * iPlace + 1 - this.nbPlaces) * h) / 2];\r\n        else\r\n            return [this.cx, this.cy + ((this.nbPlaces - 2 * iPlace - 1) * h) / 2];\r\n    }\r\n};\r\n\r\n/*\r\n  Retourne l'id de la case contenant les coordonnées (x,y), ou -1 si il n'y\r\n  a pas de case à ces coordonnées.\r\n*/\r\nContainer.prototype.placeId = function (x, y) {\r\n    for (var iPlace = 0; iPlace < this.nbPlaces; iPlace++) {\r\n        var c = this.placeCenter(iPlace);\r\n        var w = this.widthPlace,\r\n            h = this.heightPlace;\r\n        if (x >= c[0] - w / 2 && x <= c[0] + w / 2 && y >= c[1] - h / 2 && y <= c[1] + h / 2)\r\n            return iPlace;\r\n    }\r\n    return -1;\r\n};\r\n\r\nContainer.prototype.isInContainer = function (x, y) {\r\n    return this.placeId(x, y) !== -1;\r\n};\r\n\r\n// If the point (x,y) is in place i, return a real number between 0 and 1\r\n// to give its relative position in the place. For example, a value of\r\n// 0.1 means that the point is near from the common border of places i and i-1,\r\n// and a value of 0.5 indicates a position in the middle of the place i.\r\nContainer.prototype.ratioPositionInPlace = function (x, y) {\r\n    var c0 = this.placeCenter(0),\r\n        c1 = this.placeCenter(1);\r\n    var c0p = [x - c0[0], y - c0[1]];\r\n    var c0c1 = [c1[0] - c0[0], c1[1] - c0[1]];\r\n    var prodScal = c0p[0] * c0c1[0] + c0p[1] * c0c1[1];\r\n    var posAbs = parseFloat(prodScal) / parseFloat(c0c1[0] * c0c1[0] + c0c1[1] * c0c1[1]) + 0.5;\r\n    return posAbs - this.placeId(x, y);\r\n};\r\n\r\n/*\r\n  Renvoie l'action correspondant à ce qu'il faudrait faire si un objet\r\n  l'objet est laché en position (x,y).\r\n */\r\nContainer.prototype.getCorrespondingAction = function (el, x, y) {\r\n\r\n    var pos = this.placeId(x, y);\r\n    var ratio = this.ratioPositionInPlace(x, y);\r\n    if (pos === -1)\r\n        return null;\r\n\r\n    if (this.dropMode === 'replace')\r\n        return action(this, pos, 'replace');\r\n\r\n    if (this.dropMode === 'insert-replace') {\r\n        if (ratio < 0.25)\r\n            return action(this, pos, 'insert');\r\n        if (ratio > 0.75 && pos + 1 < this.nbPlaces)\r\n            return action(this, pos + 1, 'insert');\r\n        return action(this, pos, 'replace');\r\n    }\r\n\r\n    if (this.dropMode === 'insert') {\r\n        if (ratio < 0.25)\r\n            return action(this, pos, 'insert');\r\n        if (ratio > 0.75 && pos + 1 < this.nbPlaces)\r\n            return action(this, pos + 1, 'insert');\r\n        return null;\r\n    }\r\n\r\n    if (this.dropMode === 'insertBefore') {\r\n        if (ratio < 0.75)\r\n            return action(this, pos, 'insert');\r\n        else if (ratio > 0.75 && pos + 1 < this.nbPlaces)\r\n            return action(this, pos + 1, 'insert');\r\n        else\r\n            return null;\r\n    }\r\n\r\n    alert('dropMode ?');\r\n};\r\n\r\n/*\r\n  retourne le tableau correspondant à la liste des objets qu'aurait notre container\r\n  s'il l'action correspondant aux paramêtres était effectuée.\r\n*/\r\nContainer.prototype.getElementsAfterDrop = function (srcCont, srcPos, dstCont, dstPos, dropType) {\r\n\r\n    var res = [];\r\n    for (var i = 0; i < this.nbPlaces; i++)\r\n        res[i] = this.draggableElements[i];\r\n    res[this.nbPlaces] = null;\r\n\r\n    //removal\r\n    if (this === srcCont) {\r\n        if (this.dropMode === 'replace')\r\n            res[srcPos] = null;\r\n        else {\r\n            i = srcPos;\r\n            while (i + 1 <= this.nbPlaces && this.draggableElements[i] !== null) {\r\n                res[i] = res[i + 1];\r\n                i++;\r\n            }\r\n        }\r\n    }\r\n\r\n    //push\r\n    var el = srcCont.draggableElements[srcPos];\r\n    if (this === dstCont) {\r\n        if (dropType === 'replace')\r\n            res[dstPos] = el;\r\n        else {\r\n            var end = dstPos;\r\n            while (end < this.nbPlaces && res[end] !== null)\r\n                end++;\r\n            for (i = end; i > dstPos; i--)\r\n                res[i] = res[i - 1];\r\n            res[dstPos] = el;\r\n        }\r\n    }\r\n\r\n    return res;\r\n};\r\n\r\n/* Fill the place at the specified with the given element. */\r\nContainer.prototype.createAt = function (iPlace, ident, element) {\r\n\r\n    // Complain if there is already an element at the given index.\r\n    if (this.draggableElements[iPlace])\r\n        throw \"a draggable element at index \" + iPlace + \" already exists in container \" + this.ident;\r\n\r\n    // Compatibility with old interface where element was shapeArray.\r\n    if (element instanceof Array)\r\n        element = this.dragAndDropSystem.paper.set(element);\r\n\r\n    // Create a moveable element.\r\n    var draggableElement = new DraggableElement(this, iPlace, ident, element);\r\n    this.draggableElements[iPlace] = draggableElement;\r\n\r\n    // Move the element to its initial position.\r\n    var centerPosition = this.placeCenter(iPlace);\r\n    draggableElement.placeAt(centerPosition[0], centerPosition[1]);\r\n\r\n    return draggableElement;\r\n};\r\n\r\n/* Clear the place with the specified index. */\r\nContainer.prototype.clearPlace = function (iPlace) {\r\n    var el = this.draggableElements[iPlace];\r\n    this.draggableElements[iPlace] = null;\r\n    el.remove();\r\n};\r\n\r\nContainer.prototype.clear = function () {\r\n    // optimized version of: getObjects followed by removeObject on each of them\r\n    var elems = this.draggableElements;\r\n    for (var i = 0; i < elems.length; i++) {\r\n        var el = elems[i];\r\n        if (el !== null) {\r\n            elems[i] = null;\r\n            el.remove();\r\n        }\r\n    }\r\n};\r\n\r\nContainer.prototype.getObjects = function () {\r\n    var res = [];\r\n    for (var i = 0; i < this.nbPlaces; i++) {\r\n        var el = this.draggableElements[i];\r\n        res.push(el && el.ident);\r\n    }\r\n    return res;\r\n};\r\n\r\nContainer.prototype.setObjects = function (objects) {\r\n    for (var iPlace = 0; iPlace < this.nbPlaces; iPlace++) {\r\n        var object = objects[iPlace];\r\n        this.draggableElements[iPlace] = object;\r\n        if (object !== null) {\r\n            object.container = this;\r\n            object.iPlace = iPlace;\r\n        }\r\n    }\r\n};\r\n\r\nContainer.prototype.getElementOver = function (srcEl, x, y) {\r\n    for (var i = 0; i < this.nbPlaces; i++) {\r\n        var el = this.draggableElements[i];\r\n        if (el !== null && el !== srcEl) {\r\n            if (x >= el.component.cx - this.widthPlace / 2 - 1 && x <= el.component.cx + this.widthPlace / 2 + 1)\r\n                if (y >= el.component.cy - this.heightPlace / 2 - 1 && y <= el.component.cy + this.heightPlace / 2 + 1)\r\n                    return el;\r\n        }\r\n    }\r\n    return null;\r\n};\r\n\r\n/*\r\n  Fait apparaitre le trait rouge ou le carré jaune en pointillé.\r\n*/\r\nContainer.prototype.showIndicator = function (act) {\r\n    if (this.dragDisplayMode != 'marker')\r\n        return;\r\n\r\n    var paper = this.dragAndDropSystem.paper;\r\n    var c = this.placeCenter(act.dstPos);\r\n    var w = this.widthPlace,\r\n        h = this.heightPlace;\r\n\r\n    if (act.dropType === 'replace')\r\n        this.indicator = paper.rect(c[0] - w / 2, c[1] - h / 2, w, h).attr({\r\n            'stroke': 'red',\r\n            'stroke-width': '4'\r\n        });\r\n\r\n    if (act.dropType === 'insert') {\r\n        var prevC = this.placeCenter(act.dstPos - 1);\r\n        if (this.direction === 'vertical') {\r\n            var y = (prevC[1] + c[1]) / 2;\r\n            this.indicator = paper.rect(c[0] - 3 * w / 4, y, 3 * w / 2, 1).attr({\r\n                'stroke': 'red',\r\n                'stroke-width': '4'\r\n            });\r\n        } else {\r\n            var x = (prevC[0] + c[0]) / 2;\r\n            this.indicator = paper.rect(x, c[1] - 3 * h / 4, 1, 3 * h / 2).attr({\r\n                'stroke': 'red',\r\n                'stroke-width': '4'\r\n            });\r\n        }\r\n    }\r\n};\r\n\r\nContainer.prototype.hideIndicator = function () {\r\n    if (this.indicator !== null)\r\n        this.indicator.remove();\r\n    this.indicator = null;\r\n};\r\n\r\nContainer.prototype.updateSource = function () {\r\n    if (this.type === 'source' && this.draggableElements[0] === null) {\r\n        // Fill the source container's single place using a copy of the source\r\n        // component.\r\n        var component = this.sourceComponent.clone();\r\n        return this.createAt(0, this.ident, component);\r\n    }\r\n};\r\n\r\n/*\r\n  Demande de faire un affichage correspondant à l'état actuel\r\n  du container (et dessinant chacun de ses objets contenus à la bonne place)\r\n*/\r\nContainer.prototype.updateDisplay = function () {\r\n    this.updateSource();\r\n    this.placeHolder.hide();\r\n    for (var i = 0; i < this.draggableElements.length; i++) {\r\n        var el = this.draggableElements[i];\r\n        if (el !== null) {\r\n            var center = this.placeCenter(i);\r\n            el.component.placeAtWithAnim(center[0], center[1], this.timeAnim);\r\n            el.component.show();\r\n        }\r\n    }\r\n};\r\n\r\n/*\r\n  Demande de montrer un affichage correspondant à l'état dans lequel deviendrait\r\n  le container si on faisait la manipulation passée en paramêtre.\r\n*/\r\nContainer.prototype.updateIntermediateDisplay = function (srcCont, srcPos, dstCont, dstPos, dropType) {\r\n    this.placeHolder.hide();\r\n    var intermed = this.getElementsAfterDrop(srcCont, srcPos, dstCont, dstPos, dropType);\r\n    var i, center;\r\n\r\n    if (this.dragDisplayMode === 'preview') {\r\n        for (i = 0; i <= this.nbPlaces; i++) {\r\n            center = this.placeCenter(i);\r\n            if (intermed[i] !== null) {\r\n                if (intermed[i] === srcCont.draggableElements[srcPos]) {\r\n                    this.placeHolder.show();\r\n                    this.placeHolder.placeAt(center[0], center[1]);\r\n                    this.placeHolder.toFront();\r\n                    srcCont.draggableElements[srcPos].show();\r\n                    srcCont.draggableElements[srcPos].toFront();\r\n                } else {\r\n                    intermed[i].component.placeAtWithAnim(center[0], center[1], this.timeAnim);\r\n                    intermed[i].show();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    if (this.dragDisplayMode === 'marker') {\r\n        if (this.dropMode === 'replace')\r\n            return;\r\n\r\n        for (i = 0; i < this.nbPlaces; i++) {\r\n            if (this.draggableElements[i] !== null)\r\n                this.draggableElements[i].show();\r\n        }\r\n\r\n        if (this === srcCont) {\r\n            var iPlaceIns = srcPos;\r\n            while (iPlaceIns + 1 < this.nbPlaces && this.draggableElements[iPlaceIns + 1] !== null) {\r\n                center = this.placeCenter(iPlaceIns);\r\n                this.draggableElements[iPlaceIns + 1].component.placeAtWithAnim(center[0], center[1], this.timeAnim);\r\n                iPlaceIns++;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (intermed[this.nbPlaces] !== null)\r\n        intermed[this.nbPlaces].cross();\r\n};\r\n\n},{\"./action\":1,\"./component\":2,\"./draggable_element\":5,\"./utils\":7}],4:[function(require,module,exports){\n'use strict';\r\n\r\n/*\r\n  paper: paperRaphael, //le canvas Raphael dans lequel on dessine\r\n  keepLastGoodAction : // ou false, indique si on garde la dernière action valide comme référence. \r\n                       // (par defaut à true)\r\n\r\nCallbacks :\r\n   canBeTaken(containerID, position) : retourne si l'objet peut être attrappé par l'utilisateur\r\n\r\n   actionIfDropped(srcContainerID, srcPos, dstContainerID, dstPos, dropType) :\r\n       dropType: “insert” ou “replace”\r\n       retourne :\r\n       - true si l'objet source peut être inséré à cette destination\r\n       - false si on refuse de l’insérer\r\n       - un objet action(otherDstContId, otherDstPos, otherDropType) pour envoyer l’objet source ailleurs\r\n\r\n   drop(srcContainerID, srcPos, dstContainerID, dstPos, dropType) :\r\n      dropType: “insert” ou “replace”\r\n      appelé lorsque l'on vient de dropper l'objet\r\n\r\n   actionIfEjected(refElement, previousContainerId, previousPos) :\r\n      appelée lorsqu’un objet est éjecté, par exemple parce qu’il vient d’être\r\n      remplacé par un autre ou bien parce qu’il était en dernière position d’un\r\n      conteneur et qu’une insertion le fait sortir.\r\n      retourne :\r\n      - null si l’objet éjecté doit être détruit.\r\n      - un objet action(dstContId, dstPos, dropType) pour envoyer l’objet ailleurs\r\n          (l’action est alors traitée, entrainant notamment un appel a drop).\r\n\r\n   ejected(refEl, previousCont, previousPos) : indique qu'il y a eu une ejection\r\n*/\r\n\r\n/* TODO: move all references to draggableElements into container.js */\r\n\r\nvar action = require('./action'),\r\n    container = require('./container'),\r\n    utils = require('./utils'),\r\n    isUndefined = utils.isUndefined,\r\n    notIn = utils.notIn;\r\n\r\nmodule.exports = DragAndDropSystem;\r\n\r\nfunction DragAndDropSystem (params) {\r\n    var overridable, prop;\r\n\r\n    if (isUndefined(params.paper)) {\r\n        alert('paper should be defined');\r\n    }\r\n    this.paper = params.paper;\r\n\r\n    this.keepLastGoodAction = true;\r\n    this.containers = [];\r\n    this.lastDisplayedAction = null;\r\n    this.lastOver = -1;\r\n\r\n    // Assign each property in params to this, overriding the default behavior / values.\r\n    overridable = ['keepLastGoodAction', 'canBeTaken', 'actionIfDropped', 'drop', 'actionIfEjected', 'ejected', 'over'];\r\n    for (prop in params) {\r\n        if (params.hasOwnProperty(prop) && !notIn(prop, overridable)) {\r\n            this[prop] = params[prop];\r\n        }\r\n    }\r\n\r\n    // Create a temporary container, useful for ejection.\r\n    this.addContainer({\r\n        ident: 'temporaryContainer',\r\n        cx: -1000,\r\n        cy: -1000,\r\n        nbPlaces: 1,\r\n        widthPlace: 10,\r\n        heigthPlace: 10,\r\n        direction: 'vertical',\r\n        align: 'top',\r\n        dropMode: 'replace',\r\n        dragDiplayMode: 'marker',\r\n        placeBackgroundArray: null,\r\n        type: 'list'\r\n    });\r\n\r\n}\r\n\r\nDragAndDropSystem.prototype.addContainer = function (params) {\r\n    var newContainer = container(this, params);\r\n    this.containers.push(newContainer);\r\n    return newContainer;\r\n};\r\n\r\nDragAndDropSystem.prototype.removeContainer = function (cont) {\r\n    for (var i = 0; i < this.containers.length; i++) {\r\n        if (this.containers[i] === cont) {\r\n            this.containers[i] = this.containers[this.containers.length - 1];\r\n            this.containers.pop();\r\n        }\r\n    }\r\n};\r\n\r\nDragAndDropSystem.prototype.getContainer = function (containerIdent) {\r\n    if (containerIdent === null)\r\n        return null;\r\n    for (var iCont = 0; iCont < this.containers.length; iCont++) {\r\n        var container = this.containers[iCont];\r\n        if (container.ident === containerIdent)\r\n            return container;\r\n    }\r\n    return null;\r\n};\r\n\r\n// Return an array containing the (string) identifiers of the container's\r\n// elements.\r\nDragAndDropSystem.prototype.getObjects = function (containerIdent) {\r\n    return this.getContainer(containerIdent).getObjects();\r\n};\r\n\r\nDragAndDropSystem.prototype.insertObject = function (containerIdent, pos, elem) {\r\n    return this.getContainer(containerIdent).createAt(pos, elem.ident, elem.elements);\r\n};\r\n\r\nDragAndDropSystem.prototype.insertObjects = function (containerIdent, pos, elems) {\r\n    // optimized version of insertObject applied to each of the elems\r\n    var container = this.getContainer(containerIdent);\r\n    for (var i = 0; i < elems.length; i++) {\r\n        var elem = elems[i];\r\n        if (elem !== null)\r\n            container.createAt(pos + i, elem.ident, elem.elements);\r\n    }\r\n};\r\n\r\nDragAndDropSystem.prototype.removeObject = function (containerIdent, pos) {\r\n    this.getContainer(containerIdent).clearPlace(pos);\r\n};\r\n\r\nDragAndDropSystem.prototype.removeAllObjects = function (containerIdent) {\r\n    var container = this.getContainer(containerIdent);\r\n    if (container)\r\n        container.clear();\r\n};\r\n\r\nDragAndDropSystem.prototype.userActionToAction = function (act) {\r\n    // The user uses identifier instead of a reference for containers.\r\n    var container = this.getContainer(act.dstCont);\r\n    return action(container, act.dstPos, act.dropType);\r\n};\r\n\r\n// return the action object corresponding to what to do if el is dropped here\r\nDragAndDropSystem.prototype.getCorrespondingAction = function (el, cx, cy) {\r\n    var srcCont = el.container,\r\n        srcPos = el.iPlace,\r\n        actUser;\r\n\r\n    // We test if one container can receive\r\n    for (var iCont = 0; iCont < this.containers.length; iCont++) {\r\n        var dstCont = this.containers[iCont];\r\n        if (dstCont.isInContainer(cx, cy)) {\r\n            var act = dstCont.getCorrespondingAction(el, cx, cy);\r\n            if (act === null)\r\n                continue;\r\n            actUser = this.actionIfDropped(srcCont.ident, srcPos, act.dstCont.ident, act.dstPos, act.dropType);\r\n            if (typeof actUser === 'object')\r\n                return this.userActionToAction(actUser);\r\n            if (typeof actUser === 'boolean' && actUser)\r\n                return act;\r\n        }\r\n    }\r\n\r\n    // Here, no container can receive, we thus call actionIfDropped for an empty dst.\r\n    actUser = this.actionIfDropped(srcCont.ident, srcPos, null, null, 'insert');\r\n    if (typeof actUser === 'object')\r\n        return this.userActionToAction(actUser);\r\n    if (typeof actUser === 'boolean' && actUser)\r\n        return action(null, null, 'insert');\r\n\r\n    // Default behaviour\r\n    if (this.keepLastGoodAction && this.lastDisplayedAction !== null)\r\n        return this.lastDisplayedAction;\r\n\r\n    return action(srcCont, srcPos, srcCont.dropMode);\r\n};\r\n\r\nDragAndDropSystem.prototype.hideIndicators = function () {\r\n    for (var iCont = 0; iCont < this.containers.length; iCont++)\r\n        this.containers[iCont].hideIndicator();\r\n};\r\n\r\nDragAndDropSystem.prototype.updateDisplay = function () {\r\n    for (var iCont = 0; iCont < this.containers.length; iCont++)\r\n        this.containers[iCont].updateDisplay();\r\n};\r\n\r\nDragAndDropSystem.prototype.updateIntermediateDisplay = function (srcCont, srcPos, dstCont, dstPos, dropType) {\r\n    for (var iCont = 0; iCont < this.containers.length; iCont++)\r\n        this.containers[iCont].updateIntermediateDisplay(srcCont, srcPos, dstCont, dstPos, dropType);\r\n};\r\n\r\nDragAndDropSystem.prototype.getElementOver = function (srcEl, x, y) {\r\n    for (var iCont = 0; iCont < this.containers.length; iCont++) {\r\n        var el = this.containers[iCont].getElementOver(srcEl, x, y);\r\n        if (el !== null)\r\n            return el;\r\n    }\r\n    return null;\r\n};\r\n\r\n// Internal callbacks\r\n\r\nDragAndDropSystem.prototype.hasBeenTaken = function (el) {\r\n    // no-op\r\n};\r\n\r\nDragAndDropSystem.prototype.hasBeenMoved = function (el, cx, cy) {\r\n    if(this.disabled) {\r\n        return;\r\n    }\r\n    var action = this.getCorrespondingAction(el, cx, cy);\r\n    var elOver = this.getElementOver(el, cx, cy);\r\n    if (this.lastOver !== elOver) {\r\n        this.lastOver = elOver;\r\n        if (this.lastOver !== null)\r\n            this.over(el.container.ident, el.iPlace, elOver.container.ident, elOver.iPlace);\r\n        else\r\n            this.over(el.container.ident, el.iPlace, null, 0);\r\n    }\r\n    if (this.lastDisplayedAction === null || !action.sameAs(this.lastDisplayedAction)) {\r\n        this.lastDisplayedAction = action;\r\n        this.hideIndicators();\r\n        if (action.dstCont !== null) {\r\n            action.dstCont.showIndicator(action);\r\n            el.toFront();\r\n        }\r\n        this.updateIntermediateDisplay(el.container, el.iPlace, action.dstCont, action.dstPos, action.dropType);\r\n    }\r\n};\r\n\r\nDragAndDropSystem.prototype.hasBeenDropped = function (el, cx, cy) {\r\n    if(this.disabled) {\r\n        return;\r\n    }\r\n    this.hideIndicators();\r\n    var action = this.getCorrespondingAction(el, cx, cy);\r\n    var srcCont = el.container,\r\n        srcPos = el.iPlace;\r\n    this.handleDrop(srcCont, srcPos, action.dstCont, action.dstPos, action.dropType);\r\n    this.lastDisplayedAction = null;\r\n    this.lastOver = -1;\r\n};\r\n\r\nDragAndDropSystem.prototype.handleDrop = function (srcCont, srcPos, dstCont, dstPos, dropType) {\r\n\r\n    var newObjects = [];\r\n    var iDstCont = -1;\r\n    var ejected = null;\r\n    var iCont;\r\n\r\n    // Build each container's array of elements after the drop.\r\n    for (iCont = 0; iCont < this.containers.length; iCont++) {\r\n        var container = this.containers[iCont];\r\n        newObjects.push(container.getElementsAfterDrop(srcCont, srcPos, dstCont, dstPos, dropType));\r\n\r\n        // Save the index of the destination container, if any.\r\n        if (container === dstCont)\r\n            iDstCont = iCont;\r\n\r\n        // If an element was pushed past the end of the container, it will be ejected.\r\n        var elPastEnd = newObjects[iCont][container.nbPlaces];\r\n        if (elPastEnd !== null) {\r\n            ejected = {\r\n                refEl: elPastEnd,\r\n                previousCont: container,\r\n                previousPos: container.nbPlaces - 1\r\n            };\r\n        }\r\n\r\n    }\r\n\r\n    // If an element was overwritten, it will be ejected.\r\n    if (iDstCont !== -1 && dropType === 'replace' && newObjects[iDstCont][dstPos] !== null && dstCont.draggableElements[dstPos] !== null && newObjects[iDstCont][dstPos] !== dstCont.draggableElements[dstPos]) {\r\n        ejected = {\r\n            refEl: dstCont.draggableElements[dstPos],\r\n            previousCont: this.containers[iDstCont],\r\n            previousPos: dstPos\r\n        };\r\n    }\r\n\r\n    // If an element was dropped outside any container, it will be ejected.\r\n    if (dstCont === null) {\r\n        ejected = {\r\n            refEl: srcCont.draggableElements[srcPos],\r\n            previousCont: srcCont,\r\n            previousPos: srcPos\r\n        };\r\n    }\r\n\r\n    // Overwrite the old state with the new state.\r\n    for (iCont = 0; iCont < this.containers.length; iCont++) {\r\n        this.containers[iCont].setObjects(newObjects[iCont]);\r\n    }\r\n\r\n    // Move each element to its new position.\r\n    this.updateDisplay();\r\n\r\n    if (dstCont !== null) {\r\n        this.drop(srcCont.ident, srcPos, dstCont.ident, dstPos, dropType);\r\n    } else {\r\n        this.drop(srcCont.ident, srcPos, null);\r\n    }\r\n\r\n    //If needed, we process the ejection\r\n    if (ejected !== null) {\r\n        this.handleEjection(ejected.refEl, ejected.previousCont, ejected.previousPos);\r\n    }\r\n\r\n};\r\n\r\nDragAndDropSystem.prototype.handleEjection = function (refEl, previousCont, previousPos) {\r\n    var act = this.actionIfEjected(refEl, previousCont.ident, previousPos);\r\n    refEl.show(); // why?\r\n    if (act === null) {\r\n        refEl.remove();\r\n    } else {\r\n        //push in temporary container, little hack\r\n        act = this.userActionToAction(act);\r\n        this.containers[0].draggableElements[0] = refEl;\r\n        refEl.container = this.containers[0];\r\n        refEl.iPlace = 0;\r\n        this.handleDrop(this.containers[0], 0, act.dstCont, act.dstPos, act.dropType);\r\n    }\r\n\r\n    this.ejected(refEl, previousCont.ident, previousPos);\r\n};\r\n\r\n// Authorization callbacks, user-overridable.\r\n\r\nDragAndDropSystem.prototype.canBeTaken = function (containerId, iPlace) {\r\n    return true;\r\n};\r\nDragAndDropSystem.prototype.actionIfDropped = function (srcContId, srcPos, dstContId, dstPos, dropType) {\r\n    return true;\r\n};\r\n\r\nDragAndDropSystem.prototype.disable = function () {\r\n    this.disabled = true;\r\n};\r\n\r\n// User callbacks\r\n\r\nDragAndDropSystem.prototype.drop = function (srcContId, srcPos, dstContId, dstPos, dropType) {};\r\nDragAndDropSystem.prototype.over = function (srcContId, srcPos, dstContId, dstPos) {};\r\nDragAndDropSystem.prototype.actionIfEjected = function (refEl, previousCont, previousPos) {\r\n    return null;\r\n};\r\nDragAndDropSystem.prototype.ejected = function (refEl, previousCont, previousPos) {};\r\n\n},{\"./action\":1,\"./container\":3,\"./utils\":7}],5:[function(require,module,exports){\n'use strict';\r\n\r\nvar component = require('./component');\r\n\r\nmodule.exports = DraggableElement;\r\n\r\nfunction DraggableElement(container, iPlace, ident, element) {\r\n    this.dragAndDropSystem = container.dragAndDropSystem;\r\n    this.ident = ident;\r\n    this.container = container;\r\n    this.iPlace = iPlace;\r\n    this.component = component(element);\r\n    this.dragState = null;\r\n    this.crossShape = null;\r\n    var self = this;\r\n    initDrag(this.component,container,iPlace,self);\r\n//     this.component.drag(\r\n//         function (dx, dy) {\r\n//             return self._moveDragCallback(dx, dy);\r\n//         },\r\n//         function () {\r\n//             return self._startDragCallback();\r\n//         },\r\n//         function () {\r\n//             return self._endDragCallback();\r\n//         });\r\n};\r\n\r\nfunction initDrag(comp,container,iPlace,o) {\r\n    comp.drag(\r\n        function(container,iPlace){\r\n            return o._moveDragCallback(container,iPlace)},\r\n        function(){\r\n            return o._startDragCallback()},\r\n        function(){\r\n            comp.undrag();\r\n            initDrag(comp,container,iPlace,o);\r\n            return o._endDragCallback()})\r\n};\r\n\r\n\r\nDraggableElement.prototype.remove = function () {\r\n    this.component.remove();\r\n};\r\n\r\nDraggableElement.prototype.cross = function () {\r\n    this.component.halfHide();\r\n    /*\r\n    var cx = this.component.cx, cy = this.component.cy;\r\n    var w = this.container.widthPlace, h = this.container.heightPlace;\r\n    var paper = this.dragAndDropSystem.paper;\r\n    var p = 'M' + (cx - w/3) + ',' + (cy + h/3) + 'L' + (cx + w/3) + ',' + (cy - h/3) + 'L' + cx + ',' + cy +\r\n       'M' + (cx - w/3) + ',' + (cy - h/3) + 'L' + (cx + w/3) + ',' + (cy + h/3);\r\n    this.crossShape = paper.path(p).attr({'stroke':'red', 'stroke-width' : '3'});\r\n    */\r\n};\r\nDraggableElement.prototype.show = function () {\r\n    if (this.crossShape !== null) {\r\n        this.crossShape.remove();\r\n        this.crossShape = null;\r\n    }\r\n    this.component.show();\r\n};\r\nDraggableElement.prototype.hide = function () {\r\n    if (this.crossShape !== null) {\r\n        this.crossShape.remove();\r\n        this.crossShape = null;\r\n    }\r\n    this.component.hide();\r\n};\r\nDraggableElement.prototype._startDragCallback = function () {\r\n    var dragNotEnded = false; \r\n    if(this.dragState) {\r\n        // If dragState exists, we are starting a drag when the previous one hasn't ended.\r\n        // This happens when dragging to a different iframe, releasing, coming back, and clicking.\r\n        // This information is stored in dragState below.\r\n        dragNotEnded = true;\r\n    }\r\n    if (this.dragAndDropSystem.canBeTaken(this.container.ident, this.iPlace)) {\r\n        this.dragState = {\r\n            ox: this.component.cx,\r\n            oy: this.component.cy,\r\n            hasReallyMoved: false,\r\n            dragNotEnded: dragNotEnded\r\n        };\r\n        this.toFront();\r\n    }\r\n};\r\nDraggableElement.prototype._moveDragCallback = function (dx, dy) {\r\n    var state = this.dragState;\r\n\r\n    // Ignore events if we are not dragging, or if the coordinates are invalid.\r\n    if (!state || isNaN(dx) || isNaN(dy))\r\n        return;\r\n\r\n    // Do not generate events until the user has dragged the component over a\r\n    // certain threshold.\r\n    if (!state.hasReallyMoved) {\r\n        if (Math.abs(dx) <= 5 && Math.abs(dy) <= 5)\r\n            return;\r\n        this.dragState.hasReallyMoved = true;\r\n        this.dragAndDropSystem.hasBeenTaken(this);\r\n    }\r\n\r\n    // Move the component and retrieve its new position.\r\n    this.component.placeAt(state.ox + dx, state.oy + dy);\r\n    var cx = this.component.cx;\r\n    var cy = this.component.cy;\r\n    this.dragAndDropSystem.hasBeenMoved(this, cx, cy);\r\n};\r\nDraggableElement.prototype._endDragCallback = function () {\r\n    // Save and clear the drag-state.\r\n    var state = this.dragState;\r\n    if (!state)\r\n        return;\r\n    this.dragState = null;\r\n\r\n    // If the item was not dragged over the threshold, reset its position.\r\n    // Bug fix: do not do this if the previous drag did not end. If the out-of-frame bug\r\n    // has occurred (see above), we expect one click to be sufficient to release the object.\r\n    if (!state.hasReallyMoved && !state.dragNotEnded) {\r\n        this.component.placeAt(state.ox, state.oy);\r\n        return;\r\n    }\r\n\r\n    // Otherwise, pass the element and drop position to the drop handler.\r\n    this.dragAndDropSystem.hasBeenDropped(this, this.component.cx, this.component.cy);\r\n};\r\n\r\nDraggableElement.prototype.placeAt = function (cx, cy) {\r\n    this.component.placeAt(cx, cy);\r\n};\r\n\r\nDraggableElement.prototype.toFront = function () {\r\n    return this.component.toFront();\r\n};\r\n\n},{\"./component\":2}],6:[function(require,module,exports){\n'use strict';\r\n\r\nvar DragAndDropSystem = require('./dragAndDropSystem');\r\nvar action = require('./action');\r\n\r\nmodule.exports = window.DragAndDropSystem = function (params) {\r\n    return new DragAndDropSystem(params);\r\n};\r\n\r\nmodule.exports.action = action;\r\n\n},{\"./action\":1,\"./dragAndDropSystem\":4}],7:[function(require,module,exports){\n\"use strict\";\r\n\r\nif (/MSIE\\s([\\d.]+)/.test(navigator.userAgent))\r\n    module.exports['ie'+parseInt(RegExp.$1, 10)] = true;\r\n\r\nmodule.exports.notIn = function (elem, elems) {\r\n    for (var i = 0, j = elems.length; i < j; i++) {\r\n        if (elems[i] === elem) return false;\r\n    }\r\n    return true;\r\n};\r\n\r\nmodule.exports.isUndefined = function (val) {\r\n    return typeof val === 'undefined';\r\n};\r\n\n},{}]},{},[6])\n\n","'use strict';\r\n\r\n// A Component is a wrapper around a single Raphael element (which can be\r\n// a set) that allows setting the position the element.\r\n// The implementation relies on the Raphael group extension to move many\r\n// elements as one, which is required in particular for IE6 (which otherwise\r\n// moves elements individually, partially redrawing the canvas between moves).\r\n\r\n/*\r\n  Outdated comment:\r\n\r\n  Component : Permet de manipuler un objet graphique composé de plusieurs\r\n  petits objets Raphael, donnés dans le tableau arrayElems. Ces sous-objets\r\n  doivent être donnés en coordonnées relatives : si un objet du tableau est\r\n  un objet Raphael centré en (10,20) alors il apparaitra en (cx+10,cy+20),\r\n  (cx,cy) étant le centre du super-objet.\r\n  Notamment, on peut faire:\r\n  - des déplacements, ce qui déplace ensemble tous les sous-objets.\r\n  - du drag&drop, en propageant les fonctions callbacks à tous  les\r\n    sous-objets, de sorte que lorsqu'un des sous-objets et déplacés,\r\n    tous les autres subissent le même déplacement. Ainsi on voit\r\n    tous les objets bouger ensemble, comme si c'était un seul gros objet.\r\n*/\r\n\r\nvar utils = require('./utils');\r\n\r\nmodule.exports = component;\r\n\r\nfunction component (elem) {\r\n    // If a component is passed, return it unchanged.\r\n    if (elem.constructor === Component)\r\n        return elem;\r\n    return new Component(elem);\r\n}\r\n\r\nfunction Component (element) {\r\n    var paper, Element, groupNode;\r\n    if (element instanceof Array)\r\n        throw \"A Raphael element is required\";\r\n    this.element = element;\r\n    this.cx = 0;\r\n    this.cy = 0;\r\n    this.opacity = 1;\r\n    paper = this.paper = element.paper;\r\n    // Retrieve the Raphael Element constructor.\r\n    Element = paper.raphael.el.constructor;\r\n    // Create a group VML or SVG node.\r\n    if (paper.raphael.vml) {\r\n        this.vml = true;\r\n        groupNode = document.createElement(\"group\");\r\n        groupNode.style.position = 'absolute';\r\n    } else {\r\n        this.vml = false;\r\n        groupNode = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\r\n    }\r\n    // Add the group node to the canvas.\r\n    paper.canvas.appendChild(groupNode);\r\n    // Wrap a Raphael element around the group node; this is not directly\r\n    // supported by Raphael, but it works for all our use cases.\r\n    this.group = new Element(groupNode, paper);\r\n    if (this.vml) {\r\n        // VML only fix: allow applying a pure translation transform to the group.\r\n        var self = this;\r\n        this.group.transform = function (t) {\r\n            if (typeof t === 'undefined')\r\n                return [['t', self.cx, self.cy]];\r\n            if (t.length === 1 && t[0][0] === 't') {\r\n                self.placeAt(t[0][1], t[0][2]);\r\n                return;\r\n            }\r\n            alert('unsupported VML group transform');\r\n        }\r\n    }\r\n    // Move the element's DOM nodes (recursing into Raphael sets) inside the\r\n    // group node.\r\n    this.addElement(element);\r\n}\r\n\r\nComponent.prototype.addElement = function (element) {\r\n    if (element.type === 'set') {\r\n        for (var i = 0, j = element.length; i < j; i++) {\r\n            this.addElement(element[i]);\r\n        }\r\n    } else {\r\n        this.group.node.appendChild(element.node);\r\n        if (!this.vml && element.type === 'text') {\r\n            // When using SVG, overlay a transparent rect over text elements to\r\n            // prevent user interaction with the text (cursor change, selection).\r\n            var bb = element.getBBox();\r\n            var overlay = this.paper.rect(bb.x,bb.y,bb.width,bb.height).attr('fill','red').attr('opacity',0);\r\n            this.group.node.appendChild(overlay.node);\r\n        }\r\n    }\r\n};\r\n\r\nComponent.prototype.clone = function () {\r\n    var clone = new Component(this.element.clone());\r\n    clone.placeAt(this.cx, this.cy);\r\n    return clone;\r\n};\r\n\r\nComponent.prototype.placeAt = function (cx, cy) {\r\n    this.cx = cx;\r\n    this.cy = cy;\r\n    if (this.vml) {\r\n        this.group.node.style.left = cx + 'px';\r\n        this.group.node.style.top = cy + 'px';\r\n    } else {\r\n        this.group.transform('t' + cx + ',' + cy);\r\n    }\r\n    return this;\r\n};\r\n\r\nComponent.prototype.placeAtWithAnim = function (cx, cy, time) {\r\n    this.cx = cx;\r\n    this.cy = cy;\r\n    this.group.animate({\r\n        transform: 't' + cx + ',' + cy\r\n    }, time, '');\r\n    return this;\r\n};\r\n\r\nComponent.prototype.remove = function () {\r\n    // Removing the group will remove the nested element.\r\n    this.group.remove();\r\n};\r\n\r\nComponent.prototype.show = function () {\r\n    if (this.opacity !== 1) {\r\n        this.group.attr('opacity', 1);\r\n        this.opacity = 1;\r\n    }\r\n    this.group.show();\r\n    return this;\r\n};\r\n\r\nComponent.prototype.hide = function () {\r\n    this.group.hide();\r\n    return this;\r\n};\r\n\r\nComponent.prototype.halfHide = function () {\r\n    this.group.attr('opacity', 0.3);\r\n    this.opacity = 0.3;\r\n    return this;\r\n};\r\n\r\nComponent.prototype.drag = function (moveDrag, startDrag, upDrag) {\r\n    this.group.drag(moveDrag, startDrag, upDrag);\r\n    return this;\r\n};\r\n\r\nComponent.prototype.undrag = function(){\r\n    this.group.undrag()\r\n    return this\r\n};\r\n\r\nComponent.prototype.toFront = function () {\r\n    this.group.toFront();\r\n    return this;\r\n};\r\n\r\nif (utils.ie6) {\r\n    // Disable animations, IE6 would animate from (0,0) to the new position,\r\n    // rather than from the old position to the new one.\r\n    Component.prototype.placeAtWithAnim = Component.prototype.placeAt;\r\n}\r\n","'use strict';\r\n\r\n/*\r\n  Un container est un ensemble de cases (aliginées verticalement ou horizontalement). On peut lui donner\r\n  beaucoup de paramêtre pour spécifier son comportement.\r\n  direction : doit valoir \"vertical\" ou \"horizontal\"\r\n  align : dans le cas vertical, peut valoir \"left\" pour indiquer que la première case est à gauche, ou \"right\"\r\n          pour indiquer que la première case est à droite. Dans le cas vertical, peut valoir \"top\" ou \"bottom\".\r\n  cx, cy : donne le centre de la case la plus haute (pour le vertical) ou la plus a gauche (pour le cas horizontal)\r\n  dropMode :\r\n     - \"replace\" : lorsqu'un objet est laché sur une case, la case détruit son éventuel objet courant pour recevoir le nouveau.\r\n     - \"insert\"  : lorsqu'un objet est laché sur la case, l'objet actuel de la case (s'il y en a un) est décalé vers la droite,\r\n                   entrainant éventuellement un autre décalage et ainsi de suite... il peut y avoir une suppression\r\n                   si le dernier objet se fait éjecter du container.\r\n     - \"insert-replace\" : lorsqu'on lache l'objet, s'il est vers le début de la case, alors on a un comportement insert,\r\n                          sinon un comportement replace.\r\n     - \"insertBefore\" : comme insert, mais la zone de drop est plus du coté du début de la case, donc ca marche mieux\r\n                        avec dragDisplayMode=\"marker\".\r\n  dragDisplayMode : peut valoir \"preview\" (pour voir le placeholder avec des tirés jaune)\r\n                    ou \"marker\" (pour voir le trait rouge).\r\n  placeBackgroundArray : définit le background que l'on met à chaque case (juste pour faire joli).\r\n  type : peut valoir \"list\", pour un container classique, ou \"source\" le container peut recréer des objets\r\n         quand on lui prend le sien.\r\n  sourceElemArray : Utile seulement dans le cas type=\"source\", définit l'objet source à dupliquer.\r\n*/\r\n\r\nvar utils = require('./utils'),\r\n    component = require('./component'),\r\n    DraggableElement = require('./draggable_element'),\r\n    action = require('./action'),\r\n    isUndefined = utils.isUndefined,\r\n    notIn = utils.notIn;\r\n\r\nmodule.exports = container;\r\n\r\nfunction container (dragAndDropSystem, params) {\r\n    var paper = dragAndDropSystem.paper;\r\n\r\n    if (isUndefined(params.ident))\r\n        params.ident = '';\r\n    if (isUndefined(params.type))\r\n        params.type = 'list';\r\n    if (notIn(params.type, ['source', 'list']))\r\n        alert('type should be \\'source\\' or \\'list\\'');\r\n\r\n    if (isUndefined(params.cx) || isUndefined(params.cy))\r\n        alert('cx and cy are not specified');\r\n\r\n    if (isUndefined(params.widthPlace))\r\n        params.widthPlace = 40;\r\n    if (isUndefined(params.heightPlace))\r\n        params.heightPlace = 40;\r\n\r\n    if (!isUndefined(params.align)) {\r\n        if (notIn(params.align, ['top', 'bottom', 'left', 'right']))\r\n            alert('align should be \\'top\\' or \\'bottom\\' or \\'left\\' or \\'right\\'');\r\n        if (params.align === 'top' || params.align === 'bottom')\r\n            params.direction = 'vertical';\r\n        else\r\n            params.direction = 'horizontal';\r\n    } else {\r\n        if (isUndefined(params.direction)) {\r\n            params.direction = 'horizontal';\r\n            params.align = 'left';\r\n        } else {\r\n            if (params.direction === 'vertical')\r\n                params.align = 'top';\r\n            else if (params.direction === 'horizontal')\r\n                params.align = 'left';\r\n            else\r\n                alert('direction should be \\'vertical\\' or \\'horizontal\\' ');\r\n        }\r\n    }\r\n\r\n    if (isUndefined(params.dragDisplayMode))\r\n        params.dragDisplayMode = 'preview';\r\n    else if (notIn(params.dragDisplayMode, ['preview', 'marker']))\r\n        alert('dragDisplayMode should be \\'preview\\' or \\'marker\\' ');\r\n\r\n    if (isUndefined(params.placeBackgroundArray)) {\r\n        var w = params.widthPlace,\r\n            h = params.heightPlace;\r\n        params.placeBackgroundArray = [paper.rect(-w / 2, -h / 2, w, h).attr('fill', 'blue')];\r\n    }\r\n\r\n    if (params.type === 'source') {\r\n        if (isUndefined(params.dropMode))\r\n            params.dropMode = 'replace';\r\n        params.nbPlaces = 1;\r\n        if (isUndefined(params.sourceElemArray))\r\n            alert('sourceElemArray should be defined');\r\n        if (params.sourceElemArray instanceof Array)\r\n            params.sourceElemArray = paper.set(params.sourceElemArray);\r\n    }\r\n\r\n    if (params.type === 'list') {\r\n        if (isUndefined(params.dropMode))\r\n            params.dropMode = 'insert';\r\n        if (isUndefined(params.nbPlaces))\r\n            params.nbPlaces = 5;\r\n    }\r\n\r\n    return new Container(\r\n        dragAndDropSystem, params.ident,\r\n        params.cx, params.cy, params.nbPlaces, params.widthPlace, params.heightPlace,\r\n        params.direction, params.align,\r\n        params.dropMode, params.dragDisplayMode,\r\n        params.placeBackgroundArray, params.type, params.sourceElemArray, params.places);\r\n\r\n}\r\n\r\nfunction Container (\r\n    dragAndDropSystem, ident, cx, cy, nbPlaces, widthPlace, heightPlace,\r\n    direction, align, dropMode, dragDisplayMode, placeBackgroundArray,\r\n    type, sourceElemArray, places) {\r\n\r\n    this.dragAndDropSystem = dragAndDropSystem;\r\n    this.ident = ident;\r\n    this.cx = cx;\r\n    this.cy = cy;\r\n    this.nbPlaces = nbPlaces;\r\n    this.widthPlace = widthPlace;\r\n    this.heightPlace = heightPlace;\r\n    this.direction = direction;\r\n    this.align = align;\r\n    this.dropMode = dropMode;\r\n    this.dragDisplayMode = dragDisplayMode;\r\n    this.type = type;\r\n    this.places = places;\r\n\r\n    this.sanityCheck();\r\n\r\n    this.placeHolder = component(\r\n        dragAndDropSystem.paper.rect(-widthPlace / 2, -heightPlace / 2, widthPlace, heightPlace)\r\n        .attr({\r\n            'stroke': 'yellow',\r\n            'stroke-width': '2',\r\n            'stroke-dasharray': '-'\r\n        }));\r\n    this.placeHolder.hide();\r\n\r\n    this.indicator = null;\r\n\r\n    //Draw places\r\n    if (placeBackgroundArray) {\r\n        var template = dragAndDropSystem.paper.set(placeBackgroundArray);\r\n        for (var iPlace = 0; iPlace < this.nbPlaces; iPlace++) {\r\n            var c = this.placeCenter(iPlace);\r\n            component(template.clone()).placeAt(c[0], c[1]);\r\n        }\r\n        template.hide();\r\n    }\r\n\r\n    // Initialize the places.\r\n    this.draggableElements = [];\r\n    for (var i = 0; i < this.nbPlaces; i++)\r\n        this.draggableElements[i] = null;\r\n\r\n    if (this.type === 'source' && sourceElemArray) {\r\n        // Make a background component, which is also used to refill the source.\r\n        var center = this.placeCenter(0);\r\n        this.sourceComponent = component(sourceElemArray);\r\n        window.sourceComponents = (window.sourceComponents || []);\r\n        window.sourceComponents.push(this.sourceComponent);\r\n        this.sourceComponent.placeAt(center[0], center[1]);\r\n        // Fill the source with a draggable element.\r\n        var draggableElement = this.updateSource();\r\n        this.sourceComponent.draggable = draggableElement;\r\n    }\r\n\r\n    this.timeAnim = 100;\r\n}\r\n\r\nContainer.prototype.sanityCheck = function () {\r\n    if (notIn(this.direction, ['vertical', 'horizontal']))\r\n        alert('direction should be \\'vertical\\' or \\'horizontal\\'!');\r\n\r\n    if (this.direction === 'vertical')\r\n        if (notIn(this.align, ['top', 'bottom']))\r\n            alert('Since direction is vertical, align should be \\'top\\' or \\'bottom\\'');\r\n    if (this.direction === 'horizontal')\r\n        if (notIn(this.align, ['left', 'right']))\r\n            alert('Since direction is horizontal, align should be \\'left\\' or \\'right\\'');\r\n\r\n    if (notIn(this.dropMode, ['replace', 'insert-replace', 'insert', 'insertBefore']))\r\n        alert('dropMode should be \\'replace\\' or \\'insert\\' or \\'insert-replace\\' or \\'insertBefore\\'');\r\n\r\n    if (notIn(this.dragDisplayMode, ['preview', 'marker']))\r\n        alert('dragDisplayMode should be \\'preview\\' or \\'marker\\' ');\r\n\r\n    if (notIn(this.type, ['list', 'source']))\r\n        alert('type should be \\'list\\' or \\'source\\'');\r\n};\r\n\r\n/*\r\n  Fonction utilitaire : retourne les coordonnées du centre de la\r\n  case à l'indice iPlace.\r\n*/\r\nContainer.prototype.placeCenter = function (iPlace) {\r\n    var w = this.widthPlace,\r\n        h = this.heightPlace;\r\n    if (!isUndefined(this.places))\r\n        return this.places[iPlace];\r\n    if (this.direction === 'horizontal') {\r\n        if (this.align === 'left')\r\n            return [this.cx + ((2 * iPlace + 1 - this.nbPlaces) * w) / 2, this.cy];\r\n        else\r\n            return [this.cx + ((this.nbPlaces - 2 * iPlace - 1) * w) / 2, this.cy];\r\n    } else {\r\n        if (this.align === 'top')\r\n            return [this.cx, this.cy + ((2 * iPlace + 1 - this.nbPlaces) * h) / 2];\r\n        else\r\n            return [this.cx, this.cy + ((this.nbPlaces - 2 * iPlace - 1) * h) / 2];\r\n    }\r\n};\r\n\r\n/*\r\n  Retourne l'id de la case contenant les coordonnées (x,y), ou -1 si il n'y\r\n  a pas de case à ces coordonnées.\r\n*/\r\nContainer.prototype.placeId = function (x, y) {\r\n    for (var iPlace = 0; iPlace < this.nbPlaces; iPlace++) {\r\n        var c = this.placeCenter(iPlace);\r\n        var w = this.widthPlace,\r\n            h = this.heightPlace;\r\n        if (x >= c[0] - w / 2 && x <= c[0] + w / 2 && y >= c[1] - h / 2 && y <= c[1] + h / 2)\r\n            return iPlace;\r\n    }\r\n    return -1;\r\n};\r\n\r\nContainer.prototype.isInContainer = function (x, y) {\r\n    return this.placeId(x, y) !== -1;\r\n};\r\n\r\n// If the point (x,y) is in place i, return a real number between 0 and 1\r\n// to give its relative position in the place. For example, a value of\r\n// 0.1 means that the point is near from the common border of places i and i-1,\r\n// and a value of 0.5 indicates a position in the middle of the place i.\r\nContainer.prototype.ratioPositionInPlace = function (x, y) {\r\n    var c0 = this.placeCenter(0),\r\n        c1 = this.placeCenter(1);\r\n    var c0p = [x - c0[0], y - c0[1]];\r\n    var c0c1 = [c1[0] - c0[0], c1[1] - c0[1]];\r\n    var prodScal = c0p[0] * c0c1[0] + c0p[1] * c0c1[1];\r\n    var posAbs = parseFloat(prodScal) / parseFloat(c0c1[0] * c0c1[0] + c0c1[1] * c0c1[1]) + 0.5;\r\n    return posAbs - this.placeId(x, y);\r\n};\r\n\r\n/*\r\n  Renvoie l'action correspondant à ce qu'il faudrait faire si un objet\r\n  l'objet est laché en position (x,y).\r\n */\r\nContainer.prototype.getCorrespondingAction = function (el, x, y) {\r\n\r\n    var pos = this.placeId(x, y);\r\n    var ratio = this.ratioPositionInPlace(x, y);\r\n    if (pos === -1)\r\n        return null;\r\n\r\n    if (this.dropMode === 'replace')\r\n        return action(this, pos, 'replace');\r\n\r\n    if (this.dropMode === 'insert-replace') {\r\n        if (ratio < 0.25)\r\n            return action(this, pos, 'insert');\r\n        if (ratio > 0.75 && pos + 1 < this.nbPlaces)\r\n            return action(this, pos + 1, 'insert');\r\n        return action(this, pos, 'replace');\r\n    }\r\n\r\n    if (this.dropMode === 'insert') {\r\n        if (ratio < 0.25)\r\n            return action(this, pos, 'insert');\r\n        if (ratio > 0.75 && pos + 1 < this.nbPlaces)\r\n            return action(this, pos + 1, 'insert');\r\n        return null;\r\n    }\r\n\r\n    if (this.dropMode === 'insertBefore') {\r\n        if (ratio < 0.75)\r\n            return action(this, pos, 'insert');\r\n        else if (ratio > 0.75 && pos + 1 < this.nbPlaces)\r\n            return action(this, pos + 1, 'insert');\r\n        else\r\n            return null;\r\n    }\r\n\r\n    alert('dropMode ?');\r\n};\r\n\r\n/*\r\n  retourne le tableau correspondant à la liste des objets qu'aurait notre container\r\n  s'il l'action correspondant aux paramêtres était effectuée.\r\n*/\r\nContainer.prototype.getElementsAfterDrop = function (srcCont, srcPos, dstCont, dstPos, dropType) {\r\n\r\n    var res = [];\r\n    for (var i = 0; i < this.nbPlaces; i++)\r\n        res[i] = this.draggableElements[i];\r\n    res[this.nbPlaces] = null;\r\n\r\n    //removal\r\n    if (this === srcCont) {\r\n        if (this.dropMode === 'replace')\r\n            res[srcPos] = null;\r\n        else {\r\n            i = srcPos;\r\n            while (i + 1 <= this.nbPlaces && this.draggableElements[i] !== null) {\r\n                res[i] = res[i + 1];\r\n                i++;\r\n            }\r\n        }\r\n    }\r\n\r\n    //push\r\n    var el = srcCont.draggableElements[srcPos];\r\n    if (this === dstCont) {\r\n        if (dropType === 'replace')\r\n            res[dstPos] = el;\r\n        else {\r\n            var end = dstPos;\r\n            while (end < this.nbPlaces && res[end] !== null)\r\n                end++;\r\n            for (i = end; i > dstPos; i--)\r\n                res[i] = res[i - 1];\r\n            res[dstPos] = el;\r\n        }\r\n    }\r\n\r\n    return res;\r\n};\r\n\r\n/* Fill the place at the specified with the given element. */\r\nContainer.prototype.createAt = function (iPlace, ident, element) {\r\n\r\n    // Complain if there is already an element at the given index.\r\n    if (this.draggableElements[iPlace])\r\n        throw \"a draggable element at index \" + iPlace + \" already exists in container \" + this.ident;\r\n\r\n    // Compatibility with old interface where element was shapeArray.\r\n    if (element instanceof Array)\r\n        element = this.dragAndDropSystem.paper.set(element);\r\n\r\n    // Create a moveable element.\r\n    var draggableElement = new DraggableElement(this, iPlace, ident, element);\r\n    this.draggableElements[iPlace] = draggableElement;\r\n\r\n    // Move the element to its initial position.\r\n    var centerPosition = this.placeCenter(iPlace);\r\n    draggableElement.placeAt(centerPosition[0], centerPosition[1]);\r\n\r\n    return draggableElement;\r\n};\r\n\r\n/* Clear the place with the specified index. */\r\nContainer.prototype.clearPlace = function (iPlace) {\r\n    var el = this.draggableElements[iPlace];\r\n    this.draggableElements[iPlace] = null;\r\n    el.remove();\r\n};\r\n\r\nContainer.prototype.clear = function () {\r\n    // optimized version of: getObjects followed by removeObject on each of them\r\n    var elems = this.draggableElements;\r\n    for (var i = 0; i < elems.length; i++) {\r\n        var el = elems[i];\r\n        if (el !== null) {\r\n            elems[i] = null;\r\n            el.remove();\r\n        }\r\n    }\r\n};\r\n\r\nContainer.prototype.getObjects = function () {\r\n    var res = [];\r\n    for (var i = 0; i < this.nbPlaces; i++) {\r\n        var el = this.draggableElements[i];\r\n        res.push(el && el.ident);\r\n    }\r\n    return res;\r\n};\r\n\r\nContainer.prototype.setObjects = function (objects) {\r\n    for (var iPlace = 0; iPlace < this.nbPlaces; iPlace++) {\r\n        var object = objects[iPlace];\r\n        this.draggableElements[iPlace] = object;\r\n        if (object !== null) {\r\n            object.container = this;\r\n            object.iPlace = iPlace;\r\n        }\r\n    }\r\n};\r\n\r\nContainer.prototype.getElementOver = function (srcEl, x, y) {\r\n    for (var i = 0; i < this.nbPlaces; i++) {\r\n        var el = this.draggableElements[i];\r\n        if (el !== null && el !== srcEl) {\r\n            if (x >= el.component.cx - this.widthPlace / 2 - 1 && x <= el.component.cx + this.widthPlace / 2 + 1)\r\n                if (y >= el.component.cy - this.heightPlace / 2 - 1 && y <= el.component.cy + this.heightPlace / 2 + 1)\r\n                    return el;\r\n        }\r\n    }\r\n    return null;\r\n};\r\n\r\n/*\r\n  Fait apparaitre le trait rouge ou le carré jaune en pointillé.\r\n*/\r\nContainer.prototype.showIndicator = function (act) {\r\n    if (this.dragDisplayMode != 'marker')\r\n        return;\r\n\r\n    var paper = this.dragAndDropSystem.paper;\r\n    var c = this.placeCenter(act.dstPos);\r\n    var w = this.widthPlace,\r\n        h = this.heightPlace;\r\n\r\n    if (act.dropType === 'replace')\r\n        this.indicator = paper.rect(c[0] - w / 2, c[1] - h / 2, w, h).attr({\r\n            'stroke': 'red',\r\n            'stroke-width': '4'\r\n        });\r\n\r\n    if (act.dropType === 'insert') {\r\n        var prevC = this.placeCenter(act.dstPos - 1);\r\n        if (this.direction === 'vertical') {\r\n            var y = (prevC[1] + c[1]) / 2;\r\n            this.indicator = paper.rect(c[0] - 3 * w / 4, y, 3 * w / 2, 1).attr({\r\n                'stroke': 'red',\r\n                'stroke-width': '4'\r\n            });\r\n        } else {\r\n            var x = (prevC[0] + c[0]) / 2;\r\n            this.indicator = paper.rect(x, c[1] - 3 * h / 4, 1, 3 * h / 2).attr({\r\n                'stroke': 'red',\r\n                'stroke-width': '4'\r\n            });\r\n        }\r\n    }\r\n};\r\n\r\nContainer.prototype.hideIndicator = function () {\r\n    if (this.indicator !== null)\r\n        this.indicator.remove();\r\n    this.indicator = null;\r\n};\r\n\r\nContainer.prototype.updateSource = function () {\r\n    if (this.type === 'source' && this.draggableElements[0] === null) {\r\n        // Fill the source container's single place using a copy of the source\r\n        // component.\r\n        var component = this.sourceComponent.clone();\r\n        return this.createAt(0, this.ident, component);\r\n    }\r\n};\r\n\r\n/*\r\n  Demande de faire un affichage correspondant à l'état actuel\r\n  du container (et dessinant chacun de ses objets contenus à la bonne place)\r\n*/\r\nContainer.prototype.updateDisplay = function () {\r\n    this.updateSource();\r\n    this.placeHolder.hide();\r\n    for (var i = 0; i < this.draggableElements.length; i++) {\r\n        var el = this.draggableElements[i];\r\n        if (el !== null) {\r\n            var center = this.placeCenter(i);\r\n            el.component.placeAtWithAnim(center[0], center[1], this.timeAnim);\r\n            el.component.show();\r\n        }\r\n    }\r\n};\r\n\r\n/*\r\n  Demande de montrer un affichage correspondant à l'état dans lequel deviendrait\r\n  le container si on faisait la manipulation passée en paramêtre.\r\n*/\r\nContainer.prototype.updateIntermediateDisplay = function (srcCont, srcPos, dstCont, dstPos, dropType) {\r\n    this.placeHolder.hide();\r\n    var intermed = this.getElementsAfterDrop(srcCont, srcPos, dstCont, dstPos, dropType);\r\n    var i, center;\r\n\r\n    if (this.dragDisplayMode === 'preview') {\r\n        for (i = 0; i <= this.nbPlaces; i++) {\r\n            center = this.placeCenter(i);\r\n            if (intermed[i] !== null) {\r\n                if (intermed[i] === srcCont.draggableElements[srcPos]) {\r\n                    this.placeHolder.show();\r\n                    this.placeHolder.placeAt(center[0], center[1]);\r\n                    this.placeHolder.toFront();\r\n                    srcCont.draggableElements[srcPos].show();\r\n                    srcCont.draggableElements[srcPos].toFront();\r\n                } else {\r\n                    intermed[i].component.placeAtWithAnim(center[0], center[1], this.timeAnim);\r\n                    intermed[i].show();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    if (this.dragDisplayMode === 'marker') {\r\n        if (this.dropMode === 'replace')\r\n            return;\r\n\r\n        for (i = 0; i < this.nbPlaces; i++) {\r\n            if (this.draggableElements[i] !== null)\r\n                this.draggableElements[i].show();\r\n        }\r\n\r\n        if (this === srcCont) {\r\n            var iPlaceIns = srcPos;\r\n            while (iPlaceIns + 1 < this.nbPlaces && this.draggableElements[iPlaceIns + 1] !== null) {\r\n                center = this.placeCenter(iPlaceIns);\r\n                this.draggableElements[iPlaceIns + 1].component.placeAtWithAnim(center[0], center[1], this.timeAnim);\r\n                iPlaceIns++;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (intermed[this.nbPlaces] !== null)\r\n        intermed[this.nbPlaces].cross();\r\n};\r\n","'use strict';\r\n\r\n/*\r\n  paper: paperRaphael, //le canvas Raphael dans lequel on dessine\r\n  keepLastGoodAction : // ou false, indique si on garde la dernière action valide comme référence. \r\n                       // (par defaut à true)\r\n\r\nCallbacks :\r\n   canBeTaken(containerID, position) : retourne si l'objet peut être attrappé par l'utilisateur\r\n\r\n   actionIfDropped(srcContainerID, srcPos, dstContainerID, dstPos, dropType) :\r\n       dropType: “insert” ou “replace”\r\n       retourne :\r\n       - true si l'objet source peut être inséré à cette destination\r\n       - false si on refuse de l’insérer\r\n       - un objet action(otherDstContId, otherDstPos, otherDropType) pour envoyer l’objet source ailleurs\r\n\r\n   drop(srcContainerID, srcPos, dstContainerID, dstPos, dropType) :\r\n      dropType: “insert” ou “replace”\r\n      appelé lorsque l'on vient de dropper l'objet\r\n\r\n   actionIfEjected(refElement, previousContainerId, previousPos) :\r\n      appelée lorsqu’un objet est éjecté, par exemple parce qu’il vient d’être\r\n      remplacé par un autre ou bien parce qu’il était en dernière position d’un\r\n      conteneur et qu’une insertion le fait sortir.\r\n      retourne :\r\n      - null si l’objet éjecté doit être détruit.\r\n      - un objet action(dstContId, dstPos, dropType) pour envoyer l’objet ailleurs\r\n          (l’action est alors traitée, entrainant notamment un appel a drop).\r\n\r\n   ejected(refEl, previousCont, previousPos) : indique qu'il y a eu une ejection\r\n*/\r\n\r\n/* TODO: move all references to draggableElements into container.js */\r\n\r\nvar action = require('./action'),\r\n    container = require('./container'),\r\n    utils = require('./utils'),\r\n    isUndefined = utils.isUndefined,\r\n    notIn = utils.notIn;\r\n\r\nmodule.exports = DragAndDropSystem;\r\n\r\nfunction DragAndDropSystem (params) {\r\n    var overridable, prop;\r\n\r\n    if (isUndefined(params.paper)) {\r\n        alert('paper should be defined');\r\n    }\r\n    this.paper = params.paper;\r\n\r\n    this.keepLastGoodAction = true;\r\n    this.containers = [];\r\n    this.lastDisplayedAction = null;\r\n    this.lastOver = -1;\r\n\r\n    // Assign each property in params to this, overriding the default behavior / values.\r\n    overridable = ['keepLastGoodAction', 'canBeTaken', 'actionIfDropped', 'drop', 'actionIfEjected', 'ejected', 'over'];\r\n    for (prop in params) {\r\n        if (params.hasOwnProperty(prop) && !notIn(prop, overridable)) {\r\n            this[prop] = params[prop];\r\n        }\r\n    }\r\n\r\n    // Create a temporary container, useful for ejection.\r\n    this.addContainer({\r\n        ident: 'temporaryContainer',\r\n        cx: -1000,\r\n        cy: -1000,\r\n        nbPlaces: 1,\r\n        widthPlace: 10,\r\n        heigthPlace: 10,\r\n        direction: 'vertical',\r\n        align: 'top',\r\n        dropMode: 'replace',\r\n        dragDiplayMode: 'marker',\r\n        placeBackgroundArray: null,\r\n        type: 'list'\r\n    });\r\n\r\n}\r\n\r\nDragAndDropSystem.prototype.addContainer = function (params) {\r\n    var newContainer = container(this, params);\r\n    this.containers.push(newContainer);\r\n    return newContainer;\r\n};\r\n\r\nDragAndDropSystem.prototype.removeContainer = function (cont) {\r\n    for (var i = 0; i < this.containers.length; i++) {\r\n        if (this.containers[i] === cont) {\r\n            this.containers[i] = this.containers[this.containers.length - 1];\r\n            this.containers.pop();\r\n        }\r\n    }\r\n};\r\n\r\nDragAndDropSystem.prototype.getContainer = function (containerIdent) {\r\n    if (containerIdent === null)\r\n        return null;\r\n    for (var iCont = 0; iCont < this.containers.length; iCont++) {\r\n        var container = this.containers[iCont];\r\n        if (container.ident === containerIdent)\r\n            return container;\r\n    }\r\n    return null;\r\n};\r\n\r\n// Return an array containing the (string) identifiers of the container's\r\n// elements.\r\nDragAndDropSystem.prototype.getObjects = function (containerIdent) {\r\n    return this.getContainer(containerIdent).getObjects();\r\n};\r\n\r\nDragAndDropSystem.prototype.insertObject = function (containerIdent, pos, elem) {\r\n    return this.getContainer(containerIdent).createAt(pos, elem.ident, elem.elements);\r\n};\r\n\r\nDragAndDropSystem.prototype.insertObjects = function (containerIdent, pos, elems) {\r\n    // optimized version of insertObject applied to each of the elems\r\n    var container = this.getContainer(containerIdent);\r\n    for (var i = 0; i < elems.length; i++) {\r\n        var elem = elems[i];\r\n        if (elem !== null)\r\n            container.createAt(pos + i, elem.ident, elem.elements);\r\n    }\r\n};\r\n\r\nDragAndDropSystem.prototype.removeObject = function (containerIdent, pos) {\r\n    this.getContainer(containerIdent).clearPlace(pos);\r\n};\r\n\r\nDragAndDropSystem.prototype.removeAllObjects = function (containerIdent) {\r\n    var container = this.getContainer(containerIdent);\r\n    if (container)\r\n        container.clear();\r\n};\r\n\r\nDragAndDropSystem.prototype.userActionToAction = function (act) {\r\n    // The user uses identifier instead of a reference for containers.\r\n    var container = this.getContainer(act.dstCont);\r\n    return action(container, act.dstPos, act.dropType);\r\n};\r\n\r\n// return the action object corresponding to what to do if el is dropped here\r\nDragAndDropSystem.prototype.getCorrespondingAction = function (el, cx, cy) {\r\n    var srcCont = el.container,\r\n        srcPos = el.iPlace,\r\n        actUser;\r\n\r\n    // We test if one container can receive\r\n    for (var iCont = 0; iCont < this.containers.length; iCont++) {\r\n        var dstCont = this.containers[iCont];\r\n        if (dstCont.isInContainer(cx, cy)) {\r\n            var act = dstCont.getCorrespondingAction(el, cx, cy);\r\n            if (act === null)\r\n                continue;\r\n            actUser = this.actionIfDropped(srcCont.ident, srcPos, act.dstCont.ident, act.dstPos, act.dropType);\r\n            if (typeof actUser === 'object')\r\n                return this.userActionToAction(actUser);\r\n            if (typeof actUser === 'boolean' && actUser)\r\n                return act;\r\n        }\r\n    }\r\n\r\n    // Here, no container can receive, we thus call actionIfDropped for an empty dst.\r\n    actUser = this.actionIfDropped(srcCont.ident, srcPos, null, null, 'insert');\r\n    if (typeof actUser === 'object')\r\n        return this.userActionToAction(actUser);\r\n    if (typeof actUser === 'boolean' && actUser)\r\n        return action(null, null, 'insert');\r\n\r\n    // Default behaviour\r\n    if (this.keepLastGoodAction && this.lastDisplayedAction !== null)\r\n        return this.lastDisplayedAction;\r\n\r\n    return action(srcCont, srcPos, srcCont.dropMode);\r\n};\r\n\r\nDragAndDropSystem.prototype.hideIndicators = function () {\r\n    for (var iCont = 0; iCont < this.containers.length; iCont++)\r\n        this.containers[iCont].hideIndicator();\r\n};\r\n\r\nDragAndDropSystem.prototype.updateDisplay = function () {\r\n    for (var iCont = 0; iCont < this.containers.length; iCont++)\r\n        this.containers[iCont].updateDisplay();\r\n};\r\n\r\nDragAndDropSystem.prototype.updateIntermediateDisplay = function (srcCont, srcPos, dstCont, dstPos, dropType) {\r\n    for (var iCont = 0; iCont < this.containers.length; iCont++)\r\n        this.containers[iCont].updateIntermediateDisplay(srcCont, srcPos, dstCont, dstPos, dropType);\r\n};\r\n\r\nDragAndDropSystem.prototype.getElementOver = function (srcEl, x, y) {\r\n    for (var iCont = 0; iCont < this.containers.length; iCont++) {\r\n        var el = this.containers[iCont].getElementOver(srcEl, x, y);\r\n        if (el !== null)\r\n            return el;\r\n    }\r\n    return null;\r\n};\r\n\r\n// Internal callbacks\r\n\r\nDragAndDropSystem.prototype.hasBeenTaken = function (el) {\r\n    // no-op\r\n};\r\n\r\nDragAndDropSystem.prototype.hasBeenMoved = function (el, cx, cy) {\r\n    if(this.disabled) {\r\n        return;\r\n    }\r\n    var action = this.getCorrespondingAction(el, cx, cy);\r\n    var elOver = this.getElementOver(el, cx, cy);\r\n    if (this.lastOver !== elOver) {\r\n        this.lastOver = elOver;\r\n        if (this.lastOver !== null)\r\n            this.over(el.container.ident, el.iPlace, elOver.container.ident, elOver.iPlace);\r\n        else\r\n            this.over(el.container.ident, el.iPlace, null, 0);\r\n    }\r\n    if (this.lastDisplayedAction === null || !action.sameAs(this.lastDisplayedAction)) {\r\n        this.lastDisplayedAction = action;\r\n        this.hideIndicators();\r\n        if (action.dstCont !== null) {\r\n            action.dstCont.showIndicator(action);\r\n            el.toFront();\r\n        }\r\n        this.updateIntermediateDisplay(el.container, el.iPlace, action.dstCont, action.dstPos, action.dropType);\r\n    }\r\n};\r\n\r\nDragAndDropSystem.prototype.hasBeenDropped = function (el, cx, cy) {\r\n    if(this.disabled) {\r\n        return;\r\n    }\r\n    this.hideIndicators();\r\n    var action = this.getCorrespondingAction(el, cx, cy);\r\n    var srcCont = el.container,\r\n        srcPos = el.iPlace;\r\n    this.handleDrop(srcCont, srcPos, action.dstCont, action.dstPos, action.dropType);\r\n    this.lastDisplayedAction = null;\r\n    this.lastOver = -1;\r\n};\r\n\r\nDragAndDropSystem.prototype.handleDrop = function (srcCont, srcPos, dstCont, dstPos, dropType) {\r\n\r\n    var newObjects = [];\r\n    var iDstCont = -1;\r\n    var ejected = null;\r\n    var iCont;\r\n\r\n    // Build each container's array of elements after the drop.\r\n    for (iCont = 0; iCont < this.containers.length; iCont++) {\r\n        var container = this.containers[iCont];\r\n        newObjects.push(container.getElementsAfterDrop(srcCont, srcPos, dstCont, dstPos, dropType));\r\n\r\n        // Save the index of the destination container, if any.\r\n        if (container === dstCont)\r\n            iDstCont = iCont;\r\n\r\n        // If an element was pushed past the end of the container, it will be ejected.\r\n        var elPastEnd = newObjects[iCont][container.nbPlaces];\r\n        if (elPastEnd !== null) {\r\n            ejected = {\r\n                refEl: elPastEnd,\r\n                previousCont: container,\r\n                previousPos: container.nbPlaces - 1\r\n            };\r\n        }\r\n\r\n    }\r\n\r\n    // If an element was overwritten, it will be ejected.\r\n    if (iDstCont !== -1 && dropType === 'replace' && newObjects[iDstCont][dstPos] !== null && dstCont.draggableElements[dstPos] !== null && newObjects[iDstCont][dstPos] !== dstCont.draggableElements[dstPos]) {\r\n        ejected = {\r\n            refEl: dstCont.draggableElements[dstPos],\r\n            previousCont: this.containers[iDstCont],\r\n            previousPos: dstPos\r\n        };\r\n    }\r\n\r\n    // If an element was dropped outside any container, it will be ejected.\r\n    if (dstCont === null) {\r\n        ejected = {\r\n            refEl: srcCont.draggableElements[srcPos],\r\n            previousCont: srcCont,\r\n            previousPos: srcPos\r\n        };\r\n    }\r\n\r\n    // Overwrite the old state with the new state.\r\n    for (iCont = 0; iCont < this.containers.length; iCont++) {\r\n        this.containers[iCont].setObjects(newObjects[iCont]);\r\n    }\r\n\r\n    // Move each element to its new position.\r\n    this.updateDisplay();\r\n\r\n    if (dstCont !== null) {\r\n        this.drop(srcCont.ident, srcPos, dstCont.ident, dstPos, dropType);\r\n    } else {\r\n        this.drop(srcCont.ident, srcPos, null);\r\n    }\r\n\r\n    //If needed, we process the ejection\r\n    if (ejected !== null) {\r\n        this.handleEjection(ejected.refEl, ejected.previousCont, ejected.previousPos);\r\n    }\r\n\r\n};\r\n\r\nDragAndDropSystem.prototype.handleEjection = function (refEl, previousCont, previousPos) {\r\n    var act = this.actionIfEjected(refEl, previousCont.ident, previousPos);\r\n    refEl.show(); // why?\r\n    if (act === null) {\r\n        refEl.remove();\r\n    } else {\r\n        //push in temporary container, little hack\r\n        act = this.userActionToAction(act);\r\n        this.containers[0].draggableElements[0] = refEl;\r\n        refEl.container = this.containers[0];\r\n        refEl.iPlace = 0;\r\n        this.handleDrop(this.containers[0], 0, act.dstCont, act.dstPos, act.dropType);\r\n    }\r\n\r\n    this.ejected(refEl, previousCont.ident, previousPos);\r\n};\r\n\r\n// Authorization callbacks, user-overridable.\r\n\r\nDragAndDropSystem.prototype.canBeTaken = function (containerId, iPlace) {\r\n    return true;\r\n};\r\nDragAndDropSystem.prototype.actionIfDropped = function (srcContId, srcPos, dstContId, dstPos, dropType) {\r\n    return true;\r\n};\r\n\r\nDragAndDropSystem.prototype.disable = function () {\r\n    this.disabled = true;\r\n};\r\n\r\n// User callbacks\r\n\r\nDragAndDropSystem.prototype.drop = function (srcContId, srcPos, dstContId, dstPos, dropType) {};\r\nDragAndDropSystem.prototype.over = function (srcContId, srcPos, dstContId, dstPos) {};\r\nDragAndDropSystem.prototype.actionIfEjected = function (refEl, previousCont, previousPos) {\r\n    return null;\r\n};\r\nDragAndDropSystem.prototype.ejected = function (refEl, previousCont, previousPos) {};\r\n","'use strict';\r\n\r\nvar component = require('./component');\r\n\r\nmodule.exports = DraggableElement;\r\n\r\nfunction DraggableElement(container, iPlace, ident, element) {\r\n    this.dragAndDropSystem = container.dragAndDropSystem;\r\n    this.ident = ident;\r\n    this.container = container;\r\n    this.iPlace = iPlace;\r\n    this.component = component(element);\r\n    this.dragState = null;\r\n    this.crossShape = null;\r\n    var self = this;\r\n    initDrag(this.component,container,iPlace,self);\r\n//     this.component.drag(\r\n//         function (dx, dy) {\r\n//             return self._moveDragCallback(dx, dy);\r\n//         },\r\n//         function () {\r\n//             return self._startDragCallback();\r\n//         },\r\n//         function () {\r\n//             return self._endDragCallback();\r\n//         });\r\n};\r\n\r\nfunction initDrag(comp,container,iPlace,o) {\r\n    comp.drag(\r\n        function(container,iPlace){\r\n            return o._moveDragCallback(container,iPlace)},\r\n        function(){\r\n            return o._startDragCallback()},\r\n        function(){\r\n            comp.undrag();\r\n            initDrag(comp,container,iPlace,o);\r\n            return o._endDragCallback()})\r\n};\r\n\r\n\r\nDraggableElement.prototype.remove = function () {\r\n    this.component.remove();\r\n};\r\n\r\nDraggableElement.prototype.cross = function () {\r\n    this.component.halfHide();\r\n    /*\r\n    var cx = this.component.cx, cy = this.component.cy;\r\n    var w = this.container.widthPlace, h = this.container.heightPlace;\r\n    var paper = this.dragAndDropSystem.paper;\r\n    var p = 'M' + (cx - w/3) + ',' + (cy + h/3) + 'L' + (cx + w/3) + ',' + (cy - h/3) + 'L' + cx + ',' + cy +\r\n       'M' + (cx - w/3) + ',' + (cy - h/3) + 'L' + (cx + w/3) + ',' + (cy + h/3);\r\n    this.crossShape = paper.path(p).attr({'stroke':'red', 'stroke-width' : '3'});\r\n    */\r\n};\r\nDraggableElement.prototype.show = function () {\r\n    if (this.crossShape !== null) {\r\n        this.crossShape.remove();\r\n        this.crossShape = null;\r\n    }\r\n    this.component.show();\r\n};\r\nDraggableElement.prototype.hide = function () {\r\n    if (this.crossShape !== null) {\r\n        this.crossShape.remove();\r\n        this.crossShape = null;\r\n    }\r\n    this.component.hide();\r\n};\r\nDraggableElement.prototype._startDragCallback = function () {\r\n    var dragNotEnded = false; \r\n    if(this.dragState) {\r\n        // If dragState exists, we are starting a drag when the previous one hasn't ended.\r\n        // This happens when dragging to a different iframe, releasing, coming back, and clicking.\r\n        // This information is stored in dragState below.\r\n        dragNotEnded = true;\r\n    }\r\n    if (this.dragAndDropSystem.canBeTaken(this.container.ident, this.iPlace)) {\r\n        this.dragState = {\r\n            ox: this.component.cx,\r\n            oy: this.component.cy,\r\n            hasReallyMoved: false,\r\n            dragNotEnded: dragNotEnded\r\n        };\r\n        this.toFront();\r\n    }\r\n};\r\nDraggableElement.prototype._moveDragCallback = function (dx, dy) {\r\n    var state = this.dragState;\r\n\r\n    // Ignore events if we are not dragging, or if the coordinates are invalid.\r\n    if (!state || isNaN(dx) || isNaN(dy))\r\n        return;\r\n\r\n    // Do not generate events until the user has dragged the component over a\r\n    // certain threshold.\r\n    if (!state.hasReallyMoved) {\r\n        if (Math.abs(dx) <= 5 && Math.abs(dy) <= 5)\r\n            return;\r\n        this.dragState.hasReallyMoved = true;\r\n        this.dragAndDropSystem.hasBeenTaken(this);\r\n    }\r\n\r\n    // Move the component and retrieve its new position.\r\n    this.component.placeAt(state.ox + dx, state.oy + dy);\r\n    var cx = this.component.cx;\r\n    var cy = this.component.cy;\r\n    this.dragAndDropSystem.hasBeenMoved(this, cx, cy);\r\n};\r\nDraggableElement.prototype._endDragCallback = function () {\r\n    // Save and clear the drag-state.\r\n    var state = this.dragState;\r\n    if (!state)\r\n        return;\r\n    this.dragState = null;\r\n\r\n    // If the item was not dragged over the threshold, reset its position.\r\n    // Bug fix: do not do this if the previous drag did not end. If the out-of-frame bug\r\n    // has occurred (see above), we expect one click to be sufficient to release the object.\r\n    if (!state.hasReallyMoved && !state.dragNotEnded) {\r\n        this.component.placeAt(state.ox, state.oy);\r\n        return;\r\n    }\r\n\r\n    // Otherwise, pass the element and drop position to the drop handler.\r\n    this.dragAndDropSystem.hasBeenDropped(this, this.component.cx, this.component.cy);\r\n};\r\n\r\nDraggableElement.prototype.placeAt = function (cx, cy) {\r\n    this.component.placeAt(cx, cy);\r\n};\r\n\r\nDraggableElement.prototype.toFront = function () {\r\n    return this.component.toFront();\r\n};\r\n","'use strict';\r\n\r\nvar DragAndDropSystem = require('./dragAndDropSystem');\r\nvar action = require('./action');\r\n\r\nmodule.exports = window.DragAndDropSystem = function (params) {\r\n    return new DragAndDropSystem(params);\r\n};\r\n\r\nmodule.exports.action = action;\r\n","\"use strict\";\r\n\r\nif (/MSIE\\s([\\d.]+)/.test(navigator.userAgent))\r\n    module.exports['ie'+parseInt(RegExp.$1, 10)] = true;\r\n\r\nmodule.exports.notIn = function (elem, elems) {\r\n    for (var i = 0, j = elems.length; i < j; i++) {\r\n        if (elems[i] === elem) return false;\r\n    }\r\n    return true;\r\n};\r\n\r\nmodule.exports.isUndefined = function (val) {\r\n    return typeof val === 'undefined';\r\n};\r\n"]}
