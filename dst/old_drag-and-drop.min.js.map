{"version":3,"sources":["action.js","component.js","container.js","dragAndDropSystem.js","draggable_element.js"],"names":["_action","dstCont","dstPos","dropType","this","sameAs","other","action","_component","cx","cy","arrayElems","paper","that","elems","nbEl","length","iEl","type","bb","getBBox","push","rect","x","y","width","height","attr","oldTransforms","Array","i","toFront","transform","placeAt","animation","time","Raphael","placeAtWithAnim","animate","move","dx","dy","moveWithAnim","drag","moveDrag","startDrag","upDrag","hasReallyMoved","clone","newArr","undefined","remove","show","hide","halfHide","component","container","_params","params","dragAndDropSystem","alert","ident","widthPlace","heightPlace","align","direction","dragDisplayMode","placeBackgroundArray","w","h","dropMode","nbPlaces","sourceElemArray","_container","places","_DragAndDropSystem","keepLastGoodAction","containers","addContainer","removeContainer","cont","pop","heigthPlace","dragDiplayMode","addDraggableElement","position","comp","dragEl","_draggableElement","draggableElement","draggableElements","start","canBeTaken","startcx","startcy","isNaN","Math","abs","hasBeenTaken","hasBeenMoved","up","hasBeenDropped","removeDraggableElement","el","getObjects","containerId","iCont","insertObject","pos","elem","createDraggable","elements","insertObjects","removeObject","removeAllObjects","userActionToAction","act","getCorrespondingAction","srcCont","srcPos","isInContainer","actUser","actionIfDropped","lastDisplayedAction","hideIndicators","hideIndicator","updateDisplay","updateIntermediateDisplay","getElementOver","srcEl","lastOver","elOver","over","showIndicator","processDeplacement","conteneurId","srcContId","dstContId","drop","actionIfEjected","refEl","previousCont","previousPos","ejected","newObjects","getElementsAfterDrop","elEjected","iDstCont","iPlace","manageEjection","DragAndDropSystem","dragAndDrop","crossShape","cross","placeHolder","stroke","stroke-width","stroke-dasharray","sanityCheck","placeCenter","placeId","c","ratioPositionInPlace","c0","c1","c0p","c0c1","prodScal","posAbs","parseFloat","ratio","res","end","placeBG","nbMax","shapesArray","sourceCompo","sourceIdent","sourcePos","cloneArray","indicator","prevC","updateSource","newSize","timeAnim","center","intermed","iPlaceIns"],"mappings":"AASA,QAAAA,SAAAC,EAAAC,EAAAC,GAEAC,KAAAH,QAAAA,EACAG,KAAAF,OAAAA,EACAE,KAAAD,SAAAA,EAEAC,KAAAC,OAAA,SAAAC,GAEA,MAAAF,MAAAH,SAAAK,EAAAL,SAAAG,KAAAF,QAAAI,EAAAJ,QAAAE,KAAAD,UAAAG,EAAAH,UAIA,QAAAI,QAAAN,EAAAC,EAAAC,GAEA,MAAA,IAAAH,SAAAC,EAAAC,EAAAC,GCVA,QAAAK,YAAAC,EAAAC,EAAAC,EAAAC,GAEA,GAAAC,GAAAT,IAGAA,MAAAK,GAAAA,EACAL,KAAAM,GAAAA,EACAN,KAAAU,MAAAH,EACAP,KAAAQ,MAAAA,EAEAR,KAAAW,KAAAX,KAAAU,MAAAE,MAEA,KAAA,GAAAC,GAAA,EAAAA,EAAAb,KAAAW,KAAAE,IAEA,GAAA,QAAAb,KAAAU,MAAAG,GAAAC,KACA,CACA,GAAAC,GAAAf,KAAAU,MAAAG,GAAAG,SACAhB,MAAAU,MAAAO,KAAAT,EAAAU,KAAAH,EAAAI,EAAAJ,EAAAK,EAAAL,EAAAM,MAAAN,EAAAO,QAAAC,KAAA,OAAA,OAAAA,KAAA,UAAA,IAWAvB,KAAAwB,cAAA,GAAAC,MACA,KAAA,GAAAC,GAAA,EAAAA,EAAA1B,KAAAU,MAAAE,OAAAc,IAEA1B,KAAAU,MAAAgB,GAAAC,UACA3B,KAAAwB,cAAAE,GAAA1B,KAAAU,MAAAgB,GAAAE,YACA5B,KAAAU,MAAAgB,GAAAE,UAAA,IAAA5B,KAAAK,GAAA,IAAAL,KAAAM,GAAAN,KAAAwB,cAAAE,GAIA1B,MAAA6B,QAAA,SAAAxB,EAAAC,GAEAN,KAAAK,GAAAA,EACAL,KAAAM,GAAAA,CAEA,KAAA,GAAAoB,GAAA,EAAAA,EAAA1B,KAAAU,MAAAE,OAAAc,IACA1B,KAAAU,MAAAgB,GAAAE,UAAA,IAAA5B,KAAAK,GAAA,IAAAL,KAAAM,GAAAN,KAAAwB,cAAAE,GACA,OAAA1B,MAGA,IAAA8B,GAAA,SAAAJ,EAAAK,GAEA,MAAAC,SAAAF,WAAAF,UAAA,IAAAnB,EAAAJ,GAAA,IAAAI,EAAAH,GAAAG,EAAAe,cAAAE,IAAAK,EAAA,IAGA/B,MAAAiC,gBAAA,SAAA5B,EAAAC,EAAAyB,GAEA/B,KAAAK,GAAAA,EACAL,KAAAM,GAAAA,CAEA,KAAA,GAAAoB,GAAA,EAAAA,EAAA1B,KAAAU,MAAAE,OAAAc,IACA1B,KAAAU,MAAAgB,GAAAQ,QAAAJ,EAAAJ,EAAAK,GACA,OAAA/B,OAGAA,KAAAmC,KAAA,SAAAC,EAAAC,GAAArC,KAAA6B,QAAA7B,KAAAK,GAAA+B,EAAApC,KAAAM,GAAA+B,IACArC,KAAAsC,aAAA,SAAAF,EAAAC,EAAAN,GAAA/B,KAAA6B,QAAA7B,KAAAK,GAAA+B,EAAApC,KAAAM,GAAA+B,EAAAN,IAWA/B,KAAAuC,KAAA,SAAAC,EAAAC,EAAAC,GAEAjC,EAAAkC,gBAAA,EACA3C,KAAAyC,UAAAA,EACAzC,KAAAwC,SAAAA,EACAxC,KAAA0C,OAAAA,CAEA,KAAA,GAAAhB,GAAA,EAAAA,EAAA1B,KAAAU,MAAAE,OAAAc,IACA1B,KAAAU,MAAAgB,GAAAa,KAAA,SAAAH,EAAAC,GAAA5B,EAAA+B,SAAAJ,EAAAC,IACA,WAAA5B,EAAAgC,aACA,WAAAhC,EAAAiC,UACA,OAAA1C,OAQAA,KAAA4C,MAAA,WAGA,IAAA,GADAC,GAAA,GAAApB,OACAC,EAAA,EAAAA,EAAA1B,KAAAW,KAAAe,IAEAmB,EAAAnB,GAAA1B,KAAAU,MAAAgB,GAAAkB,QACAE,QAAA9C,KAAAwB,cAAAE,KAEAmB,EAAAnB,GAAAmB,EAAAnB,GAAAH,KAAA,YAAAvB,KAAAwB,cAAAE,IAGA,OAAA,IAAAtB,YAAAJ,KAAAK,GAAAL,KAAAM,GAAAuC,EAAA7C,KAAAQ,QAGAR,KAAA+C,OAAA,WAEA,IAAA,GAAArB,GAAA,EAAAA,EAAA1B,KAAAU,MAAAE,OAAAc,IACA1B,KAAAU,MAAAgB,GAAAqB,UAGA/C,KAAA2B,QAAA,WAEA,IAAA,GAAAD,GAAA,EAAAA,EAAA1B,KAAAU,MAAAE,OAAAc,IACA1B,KAAAU,MAAAgB,GAAAC,WAIA3B,KAAAgD,KAAA,WAEA,IAAA,GAAAtB,GAAA,EAAAA,EAAA1B,KAAAW,KAAAe,IACA1B,KAAAU,MAAAgB,GAAAH,KAAA,gBACAvB,KAAAU,MAAAgB,GAAAH,KAAA,UAAA,MAIAvB,KAAAiD,KAAA,WAEA,IAAA,GAAAvB,GAAA,EAAAA,EAAA1B,KAAAW,KAAAe,IACA1B,KAAAU,MAAAgB,GAAAH,KAAA,UAAA,MAGAvB,KAAAkD,SAAA,WAEA,IAAA,GAAAxB,GAAA,EAAAA,EAAA1B,KAAAW,KAAAe,IACA1B,KAAAU,MAAAgB,GAAAH,KAAA,gBACAvB,KAAAU,MAAAgB,GAAAH,KAAA,UAAA,QAKA,QAAA4B,WAAA9C,EAAAC,EAAAC,EAAAC,GAAA,MAAA,IAAAJ,YAAAC,EAAAC,EAAAC,EAAAC,GCiRA,QAAA4C,WAAAC,GAEA,GAAAC,GAAAD,CAoDA,IAlDAP,QAAAQ,EAAAC,mBACAC,MAAA,qCACAV,QAAAQ,EAAAG,QACAH,EAAAG,MAAA,IACAX,QAAAQ,EAAAxC,OACAwC,EAAAxC,KAAA,QACA,UAAAwC,EAAAxC,MAAA,QAAAwC,EAAAxC,MACA0C,MAAA,sCAEAV,QAAAQ,EAAAjD,IAAAyC,QAAAQ,EAAAhD,KACAkD,MAAA,+BAEAV,QAAAQ,EAAAI,aACAJ,EAAAI,WAAA,IACAZ,QAAAQ,EAAAK,cACAL,EAAAK,YAAA,IAEAb,QAAAQ,EAAAM,OAEA,OAAAN,EAAAM,OAAA,UAAAN,EAAAM,OAAA,QAAAN,EAAAM,OAAA,SAAAN,EAAAM,OACAJ,MAAA,0DAEA,OAAAF,EAAAM,OAAA,UAAAN,EAAAM,MACAN,EAAAO,UAAA,WAEAP,EAAAO,UAAA,cAIAf,QAAAQ,EAAAO,WAEAP,EAAAO,UAAA,aACAP,EAAAM,MAAA,QAIA,YAAAN,EAAAO,UACAP,EAAAM,MAAA,MACA,cAAAN,EAAAO,UACAP,EAAAM,MAAA,OAEAJ,MAAA,mDAIAV,QAAAQ,EAAAQ,gBACAR,EAAAQ,gBAAA,UACA,WAAAR,EAAAQ,iBAAA,UAAAR,EAAAQ,iBACAN,MAAA,oDAEAV,QAAAQ,EAAAS,qBACA,CACA,GAAAvD,GAAA8C,EAAAC,kBAAA/C,MACAwD,EAAAV,EAAAI,WAAAO,EAAAX,EAAAK,WACAL,GAAAS,sBAAAvD,EAAAU,MAAA8C,EAAA,GAAAC,EAAA,EAAAD,EAAAC,GAAA1C,KAAA,OAAA,SAyBA,MArBA,UAAA+B,EAAAxC,OAEAgC,QAAAQ,EAAAY,WACAZ,EAAAY,SAAA,WAEAZ,EAAAa,SAAA,EAEArB,QAAAQ,EAAAc,iBACAZ,MAAA,sCAIA,QAAAF,EAAAxC,OAEAgC,QAAAQ,EAAAY,WACAZ,EAAAY,SAAA,UAEApB,QAAAQ,EAAAa,WACAb,EAAAa,SAAA,IAGA,GAAAE,YACAf,EAAAC,kBAAAD,EAAAG,MACAH,EAAAjD,GAAAiD,EAAAhD,GAAAgD,EAAAa,SAAAb,EAAAI,WAAAJ,EAAAK,YACAL,EAAAO,UAAAP,EAAAM,MACAN,EAAAY,SAAAZ,EAAAQ,gBACAR,EAAAS,qBAAAT,EAAAxC,KAAAwC,EAAAc,gBAAAd,EAAAgB,QCteA,QAAAC,oBAAA/D,GAEA,YACAR,MAAAQ,MAAAA,EAEAR,KAAAwE,oBAAA,EAGAxE,KAAAyE,WAAA,GAAAhD,OACAzB,KAAA0E,aAAA,SAAApB,GAIA,MAFAA,GAAAC,kBAAAvD,KACAA,KAAAyE,WAAAxD,KAAAmC,UAAAE,IACAtD,KAAAyE,WAAAzE,KAAAyE,WAAA7D,OAAA,IAGAZ,KAAA2E,gBAAA,SAAAC,GAEA,IAAA,GAAAlD,GAAA,EAAAA,EAAA1B,KAAAyE,WAAA7D,OAAAc,IACA1B,KAAAyE,WAAA/C,IAAAkD,IAEA5E,KAAAyE,WAAA/C,GAAA1B,KAAAyE,WAAAzE,KAAAyE,WAAA7D,OAAA,GACAZ,KAAAyE,WAAAI,QAMA7E,KAAA0E,cACAjB,MAAA,qBACApD,GAAA,KAAAC,GAAA,KAAA6D,SAAA,EAAAT,WAAA,GAAAoB,YAAA,GACAjB,UAAA,WAAAD,MAAA,MACAM,SAAA,UAAAa,eAAA,SACAhB,wBACAjD,KAAA,SAGAd,KAAAgF,oBAAA,SAAAvB,EAAAL,EAAA6B,EAAAC,GAEA,GAAAC,GAAA,GAAAC,mBAAA3B,EAAAL,EAAA6B,EAAAC,EACAA,GAAAG,iBAAAF,EACA/B,EAAAkC,kBAAAL,GAAAE,CAEA,IAAA1E,GAAAT,KACAuF,EAAA,WAEAvF,KAAA2C,gBACA3C,KAAA0C,SAEAjC,EAAA+E,WAAAxF,KAAAqF,iBAAAjC,UAAAK,MAAAzD,KAAAqF,iBAAAJ,YAEAjF,KAAAyF,QAAAzF,KAAAK,GACAL,KAAA0F,QAAA1F,KAAAM,GACAN,KAAA2C,gBAAA,EACA3C,KAAA2B,YAGAQ,EAAA,SAAAC,EAAAC,GAEAsD,MAAAvD,IAAAuD,MAAAtD,IAGA5B,EAAA+E,WAAAxF,KAAAqF,iBAAAjC,UAAAK,MAAAzD,KAAAqF,iBAAAJ,YAGAjF,KAAA6B,QAAA7B,KAAAyF,QAAArD,EAAApC,KAAA0F,QAAArD,IAIAuD,KAAAC,IAAA7F,KAAAK,GAAAL,KAAAyF,SAAA,GAAAG,KAAAC,IAAA7F,KAAAM,GAAAN,KAAA0F,SAAA,KAEA1F,KAAA2C,gBAAA,EACAlC,EAAAqF,aAAAX,IAEAnF,KAAA2C,gBACAlC,EAAAsF,aAAAZ,EAAAnF,KAAAK,GAAAL,KAAAM,MAGA0F,EAAA,WAEA,GAAAvF,EAAA+E,WAAAxF,KAAAqF,iBAAAjC,UAAAK,MAAAzD,KAAAqF,iBAAAJ,UAAA,CAGA,IAAAjF,KAAA2C,eAGA,WADA3C,MAAA6B,QAAA7B,KAAAyF,QAAAzF,KAAA0F,QAGA1F,MAAA2C,gBAAA,EAEAlC,EAAAwF,eAAAd,EAAAnF,KAAAK,GAAAL,KAAAM,KAMA,OAHA4E,GAAA3C,KAAAJ,EAAAoD,EAAAS,GAGAb,GAGAnF,KAAAkG,uBAAA,SAAAC,GAEA,IAAA,GAAAzE,GAAA,EAAAA,EAAA1B,KAAAsF,kBAAA1E,OAAAc,IACA1B,KAAAsF,kBAAA5D,IAAAyE,IAEAnG,KAAAsF,kBAAA5D,GAAA1B,KAAAsF,kBAAAtF,KAAAsF,kBAAA1E,OAAA,GACAZ,KAAAsF,kBAAAT,QAIA7E,KAAAoG,WAAA,SAAAC,GAEA,IAAA,GAAAC,GAAA,EAAAA,EAAAtG,KAAAyE,WAAA7D,OAAA0F,IACA,GAAAtG,KAAAyE,WAAA6B,GAAA7C,OAAA4C,EACA,MAAArG,MAAAyE,WAAA6B,GAAAF,cAGApG,KAAAuG,aAAA,SAAAF,EAAAG,EAAAC,GAEA,IAAA,GAAAH,GAAA,EAAAA,EAAAtG,KAAAyE,WAAA7D,OAAA0F,IACAtG,KAAAyE,WAAA6B,GAAA7C,OAAA4C,GACArG,KAAAyE,WAAA6B,GAAAI,gBAAAD,EAAAhD,MAAA+C,EAAAC,EAAAE,WAGA3G,KAAA4G,cAAA,SAAAP,EAAAG,EAAA9F,GAGA,IAAA,GAAA4F,GAAA,EAAAA,EAAAtG,KAAAyE,WAAA7D,OAAA0F,IACA,GAAAtG,KAAAyE,WAAA6B,GAAA7C,OAAA4C,EAEA,IAAA,GADAzB,GAAA5E,KAAAyE,WAAA6B,GACA5E,EAAA,EAAAA,EAAAhB,EAAAE,OAAAc,IAAA,CACA,GAAA+E,GAAA/F,EAAAgB,EACA,OAAA+E,GACA7B,EAAA8B,gBAAAD,EAAAhD,MAAA+C,EAAA9E,EAAA+E,EAAAE,YAQA3G,KAAA6G,aAAA,SAAAR,EAAAG,GAEA,IAAA,GAAAF,GAAA,EAAAA,EAAAtG,KAAAyE,WAAA7D,OAAA0F,IACA,GAAAtG,KAAAyE,WAAA6B,GAAA7C,OAAA4C,EACA,CACA,GAAAF,GAAAnG,KAAAyE,WAAA6B,GAAAhB,kBAAAkB,EACAxG,MAAAyE,WAAA6B,GAAAhB,kBAAAkB,GAAA,KACAL,EAAApD,WAIA/C,KAAA8G,iBAAA,SAAAT,GAGA,IAAA,GAAAC,GAAA,EAAAA,EAAAtG,KAAAyE,WAAA7D,OAAA0F,IACA,GAAAtG,KAAAyE,WAAA6B,GAAA7C,OAAA4C,EAEA,IAAA,GADA3F,GAAAV,KAAAyE,WAAA6B,GAAAhB,kBACA5D,EAAA,EAAAA,EAAAhB,EAAAE,OAAAc,IAAA,CACA,GAAAyE,GAAAzF,EAAAgB,EACA,OAAAyE,IACAzF,EAAAgB,GAAA,KACAyE,EAAApD,YASA/C,KAAA+G,mBAAA,SAAAC,GAEA,IAAA,GAAAV,GAAA,EAAAA,EAAAtG,KAAAyE,WAAA7D,OAAA0F,IACA,GAAAtG,KAAAyE,WAAA6B,GAAA7C,OAAAuD,EAAAnH,QACA,MAAAM,QAAAH,KAAAyE,WAAA6B,GAAAU,EAAAlH,OAAAkH,EAAAjH,SAEA,OAAAI,QAAA,KAAA6G,EAAAlH,OAAAkH,EAAAjH,WAIAC,KAAAiH,uBAAA,SAAAd,EAAA9F,EAAAC,GAIA,IAAA,GAFA4G,GAAAf,EAAA/C,UAAA+D,EAAAhB,EAAAlB,SAEAqB,EAAA,EAAAA,EAAAtG,KAAAyE,WAAA7D,OAAA0F,IACA,CACA,GAAAzG,GAAAG,KAAAyE,WAAA6B,EACA,IAAAzG,EAAAuH,cAAA/G,EAAAC,GACA,CACA,GAAA0G,GAAAnH,EAAAoH,uBAAAd,EAAA9F,EAAAC,EACA,IAAA,MAAA0G,EACA,QACA,IAAAK,GAAArH,KAAAsH,gBAAAJ,EAAAzD,MAAA0D,EAAAH,EAAAnH,QAAA4D,MAAAuD,EAAAlH,OAAAkH,EAAAjH,SACA,IAAA,GAAAsH,EACA,MAAAL,EACA,IAAA,GAAAK,EACA,MAAArH,MAAA+G,mBAAAM,IAKA,GAAAA,GAAArH,KAAAsH,gBAAAJ,EAAAzD,MAAA0D,EAAA,KAAA,KAAA,SACA,OAAA,IAAAE,EACAlH,OAAA,KAAA,KAAA,UACA,GAAAkH,EACArH,KAAA+G,mBAAAM,GAGArH,KAAAwE,oBAAA,MAAAxE,KAAAuH,oBACAvH,KAAAuH,oBAEApH,OAAA+G,EAAAC,EAAAD,EAAAhD,WAGAlE,KAAAwH,eAAA,WAEA,IAAA,GAAAlB,GAAA,EAAAA,EAAAtG,KAAAyE,WAAA7D,OAAA0F,IACAtG,KAAAyE,WAAA6B,GAAAmB,iBAGAzH,KAAA0H,cAAA,WAEA,IAAA,GAAApB,GAAA,EAAAA,EAAAtG,KAAAyE,WAAA7D,OAAA0F,IACAtG,KAAAyE,WAAA6B,GAAAoB,iBAGA1H,KAAA2H,0BAAA,SAAAT,EAAAC,EAAAtH,EAAAC,EAAAC,GAEA,IAAA,GAAAuG,GAAA,EAAAA,EAAAtG,KAAAyE,WAAA7D,OAAA0F,IACAtG,KAAAyE,WAAA6B,GAAAqB,0BAAAT,EAAAC,EAAAtH,EAAAC,EAAAC,IAGAC,KAAA4H,eAAA,SAAAC,EAAA1G,EAAAC,GAEA,IAAA,GAAAkF,GAAA,EAAAA,EAAAtG,KAAAyE,WAAA7D,OAAA0F,IACA,CACA,GAAAH,GAAAnG,KAAAyE,WAAA6B,GAAAsB,eAAAC,EAAA1G,EAAAC,EACA,IAAA,MAAA+E,EACA,MAAAA,GAEA,MAAA,OAIAnG,KAAA8F,aAAA,SAAAK,KAIAnG,KAAAuH,oBAAA,KACAvH,KAAA8H,SAAA,GACA9H,KAAA+F,aAAA,SAAAI,EAAA9F,EAAAC,GAEA,GAAAH,GAAAH,KAAAiH,uBAAAd,EAAA9F,EAAAC,GAEAyH,EAAA/H,KAAA4H,eAAAzB,EAAA9F,EAAAC,EAEAN,MAAA8H,WAAAC,IAEA/H,KAAA8H,SAAAC,EACA,MAAA/H,KAAA8H,SACA9H,KAAAgI,KAAA7B,EAAA/C,UAAAK,MAAA0C,EAAAlB,SAAA8C,EAAA3E,UAAAK,MAAAsE,EAAA9C,UAEAjF,KAAAgI,KAAA7B,EAAA/C,UAAAK,MAAA0C,EAAAlB,SAAA,KAAA,IAGA,MAAAjF,KAAAuH,qBAAApH,EAAAF,OAAAD,KAAAuH,uBAEAvH,KAAAuH,oBAAApH,EACAH,KAAAwH,iBACA,MAAArH,EAAAN,UAEAM,EAAAN,QAAAoI,cAAA9H,GACAgG,EAAAhD,UAAAxB,WAEA3B,KAAA2H,0BAAAxB,EAAA/C,UAAA+C,EAAAlB,SAAA9E,EAAAN,QAAAM,EAAAL,OAAAK,EAAAJ,YAIAC,KAAAiG,eAAA,SAAAE,EAAA9F,EAAAC,GAEAN,KAAAwH,gBACA,IAAArH,GAAAH,KAAAiH,uBAAAd,EAAA9F,EAAAC,GAEA4G,EAAAf,EAAA/C,UAAA+D,EAAAhB,EAAAlB,QACAjF,MAAAkI,mBAAAhB,EAAAC,EAAAhH,EAAAN,QAAAM,EAAAL,OAAAK,EAAAJ,UAEAC,KAAAuH,oBAAA,KACAvH,KAAA8H,SAAA,IAKA9H,KAAAwF,WAAA,SAAA2C,EAAAlD,GAAA,OAAA,GACAjF,KAAAsH,gBAAA,SAAAc,EAAAjB,EAAAkB,EAAAvI,EAAAC,GAAA,OAAA,GAIAC,KAAAsI,KAAA,SAAAF,EAAAjB,EAAAkB,EAAAvI,EAAAC,KACAC,KAAAgI,KAAA,SAAAI,EAAAjB,EAAAkB,EAAAvI,KACAE,KAAAuI,gBAAA,SAAAC,EAAAC,EAAAC,GAAA,MAAA,OACA1I,KAAA2I,QAAA,SAAAH,EAAAC,EAAAC,KAIA1I,KAAAkI,mBAAA,SAAAhB,EAAAC,EAAAtH,EAAAC,EAAAC,GAGA,IAAA,GADA6I,GAAA,GAAAnH,OACA6E,EAAA,EAAAA,EAAAtG,KAAAyE,WAAA7D,OAAA0F,IACAsC,EAAAtC,GAAAtG,KAAAyE,WAAA6B,GAAAuC,qBAAA3B,EAAAC,EAAAtH,EAAAC,EAAAC,EAKA,KAAA,GAHA4I,GAAA,KAGArC,EAAA,EAAAA,EAAAtG,KAAAyE,WAAA7D,OAAA0F,IACA,GAAA,MAAAsC,EAAAtC,GAAAtG,KAAAyE,WAAA6B,GAAAnC,UACA,CACA,GAAA2E,GAAAF,EAAAtC,GAAAtG,KAAAyE,WAAA6B,GAAAnC,UACAsE,EAAAzI,KAAAyE,WAAA6B,EACAqC,IAAAH,MAAAM,EAAAL,aAAAA,EAAAC,YAAA1I,KAAAyE,WAAA6B,GAAAnC,SAAA,GAKA,IAAA,GADA4E,GAAA,GACAzC,EAAA,EAAAA,EAAAtG,KAAAyE,WAAA7D,OAAA0F,IACAtG,KAAAyE,WAAA6B,IAAAzG,IACAkJ,EAAAzC,EACA,IAAA,IAAAyC,GACA,WAAAhJ,GAAA,MAAA6I,EAAAG,GAAAjJ,IAAA,MAAAD,EAAAyF,kBAAAxF,IACA8I,EAAAG,GAAAjJ,IAAAD,EAAAyF,kBAAAxF,GACA,CACA,GAAAgJ,GAAAjJ,EAAAyF,kBAAAxF,GACA2I,EAAAzI,KAAAyE,WAAAsE,GACAL,EAAA5I,CACA6I,IAAAH,MAAAM,EAAAL,aAAAA,EAAAC,YAAAA,GAIA,MAAA7I,IACA8I,GAAAH,MAAAtB,EAAA5B,kBAAA6B,GAAAsB,aAAAvB,EAAAwB,YAAAvB,GAGA,KAAA,GAAAb,GAAA,EAAAA,EAAAtG,KAAAyE,WAAA7D,OAAA0F,IAGA,IAAA,GADA1B,GAAA5E,KAAAyE,WAAA6B,GACA0C,EAAA,EAAAA,EAAApE,EAAAT,SAAA6E,IAEApE,EAAAU,kBAAA0D,GAAAJ,EAAAtC,GAAA0C,GACA,MAAApE,EAAAU,kBAAA0D,KAEApE,EAAAU,kBAAA0D,GAAA5F,UAAAwB,EACAA,EAAAU,kBAAA0D,GAAA/D,SAAA+D,EAKAhJ,MAAA0H,gBAEA,MAAA7H,EACAG,KAAAsI,KAAApB,EAAAzD,MAAA0D,EAAAtH,EAAA4D,MAAA3D,EAAAC,GAEAC,KAAAsI,KAAApB,EAAAzD,MAAA0D,EAAA,MAGA,MAAAwB,GACA3I,KAAAiJ,eAAAN,EAAA,MAAAA,EAAA,aAAAA,EAAA,cAMA3I,KAAAiJ,eAAA,SAAAT,EAAAC,EAAAC,GAEA,GAAA1B,GAAAhH,KAAAuI,gBAAAC,EAAAC,EAAAhF,MAAAiF,EACAF,GAAAxF,OACA,MAAAgE,EACAwB,EAAAzF,UAIAiE,EAAAhH,KAAA+G,mBAAAC,GACAhH,KAAAyE,WAAA,GAAAa,kBAAA,GAAAkD,EACAA,EAAApF,UAAApD,KAAAyE,WAAA,GACA+D,EAAAvD,SAAA,EACAjF,KAAAkI,mBAAAlI,KAAAyE,WAAA,GAAA,EAAAuC,EAAAnH,QAAAmH,EAAAlH,OAAAkH,EAAAjH,WAGAC,KAAA2I,QAAAH,EAAAC,EAAAhF,MAAAiF,IAMA,QAAAQ,mBAAA5F,GAEAR,QAAAQ,EAAA9C,OACAgD,MAAA,0BAEA,IAAA2F,GAAA,GAAA5E,oBAAAjB,EAAA9C,MAuBA,OArBAsC,SAAAQ,EAAAkB,qBACA2E,EAAA3E,mBAAAlB,EAAAkB,oBAEA1B,QAAAQ,EAAAkC,aACA2D,EAAA3D,WAAAlC,EAAAkC,YAEA1C,QAAAQ,EAAAgE,kBACA6B,EAAA7B,gBAAAhE,EAAAgE,iBAEAxE,QAAAQ,EAAAgF,OACAa,EAAAb,KAAAhF,EAAAgF,MAEAxF,QAAAQ,EAAAiF,kBACAY,EAAAZ,gBAAAjF,EAAAiF,iBAEAzF,QAAAQ,EAAAqF,UACAQ,EAAAR,QAAArF,EAAAqF,SAEA7F,QAAAQ,EAAA0E,OACAmB,EAAAnB,KAAA1E,EAAA0E,MAEAmB,EC7bA,QAAA/D,mBAAA3B,EAAAL,EAAA6B,EAAA9B,GAEAnD,KAAAyD,MAAAA,EACAzD,KAAAoD,UAAAA,EACApD,KAAAiF,SAAAA,EACAjF,KAAAmD,UAAAA,EAGAnD,KAAAoJ,WAAA,KAEApJ,KAAA+C,OAAA,WAEA,MAAA/C,KAAAoJ,YACApJ,KAAAoJ,WAAArG,SACA/C,KAAAoJ,WAAA,KAEApJ,KAAAmD,UAAAJ,UAGA/C,KAAAqJ,MAAA,WAEA,MAAArJ,KAAAoJ,YACApJ,KAAAoJ,WAAArG,SAEA/C,KAAAmD,UAAAD,YAIAlD,KAAAgD,KAAA,WAEA,MAAAhD,KAAAoJ,YACApJ,KAAAoJ,WAAArG,SACA/C,KAAAoJ,WAAA,KAEApJ,KAAAmD,UAAAH,QAGAhD,KAAAiD,KAAA,WAEA,MAAAjD,KAAAoJ,YACApJ,KAAAoJ,WAAArG,SACA/C,KAAAoJ,WAAA,KAEApJ,KAAAmD,UAAAF,QFxBA,GAAAoB,YAAA,SAAAd,EAAAE,EAAApD,EAAAC,EAAA6D,EAAAT,EAAAC,EAAAE,EAAAD,EAAAM,EAAAJ,EACAC,EAAAjD,EAAAsD,EAAAE,GAEA,YACAtE,MAAAuD,kBAAAA,EACAvD,KAAAyD,MAAAA,EACAzD,KAAAK,GAAAA,EACAL,KAAAM,GAAAA,EACAN,KAAAmE,SAAAA,EACAnE,KAAA0D,WAAAA,EACA1D,KAAA2D,YAAAA,EACA3D,KAAA6D,UAAAA,EACA7D,KAAA4D,MAAAA,EACA5D,KAAAkE,SAAAA,EACAlE,KAAA8D,gBAAAA,EACA9D,KAAAc,KAAAA,EACAd,KAAAsE,OAAAA,EAEAtE,KAAAsJ,YAAAnG,UAAA,EAAA,GACAI,EAAA/C,MAAAU,MAAAwC,EAAA,GAAAC,EAAA,EAAAD,EAAAC,GACApC,MAAAgI,OAAA,SAAAC,eAAA,IAAAC,mBAAA,OAAAzJ,KAAAuD,kBAAA/C,OACAR,KAAAsJ,YAAArG,OAEAjD,KAAAoE,gBAAAA,EAGApE,KAAA0J,YAAA,WAEA,YAAA7F,GAAA,cAAAA,GACAL,MAAA,mDAEA,YAAAK,GACA,OAAAD,GAAA,UAAAA,GACAJ,MAAA,kEACA,cAAAK,GACA,QAAAD,GAAA,SAAAA,GACAJ,MAAA,oEAEA,WAAAU,GAAA,kBAAAA,GAAA,UAAAA,GAAA,gBAAAA,GACAV,MAAA,kFAEA,WAAAM,GAAA,UAAAA,GACAN,MAAA,oDAEA,QAAA1C,GAAA,UAAAA,GACA0C,MAAA,sCAEAxD,KAAA0J,cAQA1J,KAAA2J,YAAA,SAAAX,GAEA,GAAAhF,GAAAhE,KAAA0D,WAAAO,EAAAjE,KAAA2D,WACA,OAAAb,SAAA9C,KAAAsE,OACAtE,KAAAsE,OAAA0E,GAEA,cAAAnF,EACA,QAAAD,GACA5D,KAAAK,IAAA,EAAA2I,EAAA,EAAAhJ,KAAAmE,UAAAH,EAAA,EAAAhE,KAAAM,KAEAN,KAAAK,IAAAL,KAAAmE,SAAA,EAAA6E,EAAA,GAAAhF,EAAA,EAAAhE,KAAAM,IAEA,OAAAsD,GACA5D,KAAAK,GAAAL,KAAAM,IAAA,EAAA0I,EAAA,EAAAhJ,KAAAmE,UAAAF,EAAA,IAEAjE,KAAAK,GAAAL,KAAAM,IAAAN,KAAAmE,SAAA,EAAA6E,EAAA,GAAA/E,EAAA,IAMAjE,KAAA4J,QAAA,SAAAzI,EAAAC,GAEA,IAAA,GAAA4H,GAAA,EAAAA,EAAAhJ,KAAAmE,SAAA6E,IACA,CACA,GAAAa,GAAA7J,KAAA2J,YAAAX,GACAhF,EAAAhE,KAAA0D,WAAAO,EAAAjE,KAAA2D,WACA,IAAAxC,GAAA0I,EAAA,GAAA7F,EAAA,GAAA7C,GAAA0I,EAAA,GAAA7F,EAAA,GAAA5C,GAAAyI,EAAA,GAAA5F,EAAA,GAAA7C,GAAAyI,EAAA,GAAA5F,EAAA,EACA,MAAA+E,GAEA,MAAA,IAGAhJ,KAAAoH,cAAA,SAAAjG,EAAAC,GAAA,MAAA,IAAApB,KAAA4J,QAAAzI,EAAAC,IAMApB,KAAA8J,qBAAA,SAAA3I,EAAAC,GAEA,GAAA2I,GAAA/J,KAAA2J,YAAA,GAAAK,EAAAhK,KAAA2J,YAAA,GACAM,GAAA9I,EAAA4I,EAAA,GAAA3I,EAAA2I,EAAA,IACAG,GAAAF,EAAA,GAAAD,EAAA,GAAAC,EAAA,GAAAD,EAAA,IACAI,EAAAF,EAAA,GAAAC,EAAA,GAAAD,EAAA,GAAAC,EAAA,GACAE,EAAAC,WAAAF,GAAAE,WAAAH,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,IAAA,EACA,OAAAE,GAAApK,KAAA4J,QAAAzI,EAAAC,IAOApB,KAAAiH,uBAAA,SAAAd,EAAAhF,EAAAC,GAEA,GAAAoF,GAAAxG,KAAA4J,QAAAzI,EAAAC,GACAkJ,EAAAtK,KAAA8J,qBAAA3I,EAAAC,EACA,OAAA,IAAAoF,EACA,KAEA,WAAAxG,KAAAkE,SACA/D,OAAAH,KAAAwG,EAAA,WAEA,kBAAAxG,KAAAkE,SAEA,IAAAoG,EACAnK,OAAAH,KAAAwG,EAAA,UACA8D,EAAA,KAAA9D,EAAA,EAAAxG,KAAAmE,SACAhE,OAAAH,KAAAwG,EAAA,EAAA,UACArG,OAAAH,KAAAwG,EAAA,WAGA,UAAAxG,KAAAkE,SAEA,IAAAoG,EACAnK,OAAAH,KAAAwG,EAAA,UACA8D,EAAA,KAAA9D,EAAA,EAAAxG,KAAAmE,SACAhE,OAAAH,KAAAwG,EAAA,EAAA,UACA,KAGA,gBAAAxG,KAAAkE,SAEA,IAAAoG,EACAnK,OAAAH,KAAAwG,EAAA,UACA8D,EAAA,KAAA9D,EAAA,EAAAxG,KAAAmE,SACAhE,OAAAH,KAAAwG,EAAA,EAAA,UAEA,SAGAhD,OAAA,eAOAxD,KAAA6I,qBAAA,SAAA3B,EAAAC,EAAAtH,EAAAC,EAAAC,GAGA,IAAA,GADAwK,MACA7I,EAAA,EAAAA,EAAA1B,KAAAmE,SAAAzC,IACA6I,EAAA7I,GAAA1B,KAAAsF,kBAAA5D,EAIA,IAHA6I,EAAAvK,KAAAmE,UAAA,KAGAnE,MAAAkH,EAEA,GAAA,WAAAlH,KAAAkE,SACAqG,EAAApD,GAAA,SAIA,KADAzF,EAAAyF,EACAzF,EAAA,GAAA1B,KAAAmE,UAAA,MAAAnE,KAAAsF,kBAAA5D,IAEA6I,EAAA7I,GAAA6I,EAAA7I,EAAA,GACAA,GAMA,IAAAyE,GAAAe,EAAA5B,kBAAA6B,EACA,IAAAnH,MAAAH,EAEA,GAAA,WAAAE,EACAwK,EAAAzK,GAAAqG,MAEA,CAEA,IADA,GAAAqE,GAAA1K,EACA0K,EAAAxK,KAAAmE,UAAA,MAAAoG,EAAAC,IACAA,GACA,KAAA9I,EAAA8I,EAAA9I,EAAA5B,EAAA4B,IACA6I,EAAA7I,GAAA6I,EAAA7I,EAAA,EACA6I,GAAAzK,GAAAqG,EAIA,MAAAoE,IAIAvK,KAAAyK,QAAAtH,UAAA,EAAA,EAAAY,EAAA/D,KAAAuD,kBAAA/C,MACA,KAAA,GAAAwI,GAAA,EAAAA,EAAAhJ,KAAAmE,SAAA6E,IACA,CACA,GAAAa,GAAA7J,KAAA2J,YAAAX,EACA,IAAAA,EACAhJ,KAAAyK,QAAA5I,QAAAgI,EAAA,GAAAA,EAAA,IAEA7J,KAAAyK,QAAA7H,QAAAf,QAAAgI,EAAA,GAAAA,EAAA,IAKA7J,KAAAsF,oBACA,KAAA,GAAA5D,GAAA,EAAAA,EAAA1B,KAAA0K,MAAAhJ,IACA1B,KAAAsF,kBAAA5D,GAAA,IAgBA,IAdA1B,KAAA0G,gBAAA,SAAAjD,EAAAwB,EAAA0F,GAEA3K,KAAAuD,kBAAAyB,oBAAAvB,EAAAzD,KAAAiF,EACA,GAAA7E,YAAAJ,KAAA2J,YAAA1E,GAAA,GAAAjF,KAAA2J,YAAA1E,GAAA,GAAA0F,EAAA3K,KAAAuD,kBAAA/C,QAEA,UAAAR,KAAAc,OAEAd,KAAA4K,YAAA5K,KAAAsF,kBAAA,GAAAnC,UAAAP,QACA5C,KAAA4K,YAAAzI,KAAA,KAAA,MACAnC,KAAA6K,YAAApH,EACAzD,KAAA8K,UAAA7F,IAIA,UAAAjF,KAAAc,KACA,CACA,GAAAiK,KACA,KAAArJ,EAAA,EAAAA,EAAA1B,KAAAoE,gBAAAxD,OAAAc,IACAqJ,EAAArJ,GAAA1B,KAAAoE,gBAAA1C,GAAAkB,OACAO,WAAAnD,KAAAK,GAAAL,KAAAM,GAAAyK,EAAA/K,KAAAuD,kBAAA/C,OAEAR,KAAA0G,gBAAA1G,KAAAyD,MAAA,EAAAzD,KAAAoE,iBAIApE,KAAAoG,WAAA,WAGA,IAAA,GADAmE,MACA7I,EAAA,EAAAA,EAAA1B,KAAAmE,SAAAzC,IACA,MAAA1B,KAAAsF,kBAAA5D,GACA6I,EAAA7I,GAAA1B,KAAAsF,kBAAA5D,GAAA+B,MAEA8G,EAAA7I,GAAA,IACA,OAAA6I,IAGAvK,KAAA4H,eAAA,SAAAC,EAAA1G,EAAAC,GAEA,IAAA,GAAAM,GAAA,EAAAA,EAAA1B,KAAAmE,SAAAzC,IACA,GAAA,MAAA1B,KAAAsF,kBAAA5D,IAAA1B,KAAAsF,kBAAA5D,IAAAmG,EACA,CACA,GAAA1B,GAAAnG,KAAAsF,kBAAA5D,EACA,IAAAP,GAAAgF,EAAAhD,UAAA9C,GAAAL,KAAA0D,WAAA,EAAA,GAAAvC,GAAAgF,EAAAhD,UAAA9C,GAAAL,KAAA0D,WAAA,EAAA,GACAtC,GAAA+E,EAAAhD,UAAA7C,GAAAN,KAAA2D,YAAA,EAAA,GAAAvC,GAAA+E,EAAAhD,UAAA7C,GAAAN,KAAA2D,YAAA,EAAA,EACA,MAAAwC,GAGA,MAAA,OAIAnG,KAAAgL,UAAA,KAKAhL,KAAAiI,cAAA,SAAAjB,GAEA,GAAA,UAAAhH,KAAA8D,gBAAA,CAGA,GAAAtD,GAAAR,KAAAuD,kBAAA/C,MACAqJ,EAAA7J,KAAA2J,YAAA3C,EAAAlH,QACAkE,EAAAhE,KAAA0D,WAAAO,EAAAjE,KAAA2D,WAKA,IAHA,WAAAqD,EAAAjH,WACAC,KAAAgL,UAAAxK,EAAAU,KAAA2I,EAAA,GAAA7F,EAAA,EAAA6F,EAAA,GAAA5F,EAAA,EAAAD,EAAAC,GAAA1C,MAAAgI,OAAA,MAAAC,eAAA,OAEA,UAAAxC,EAAAjH,SACA,CACA,GAAAkL,GAAAjL,KAAA2J,YAAA3C,EAAAlH,OAAA,EACA,IAAA,YAAAE,KAAA6D,UACA,CACA,GAAAzC,IAAA6J,EAAA,GAAApB,EAAA,IAAA,CACA7J,MAAAgL,UAAAxK,EAAAU,KAAA2I,EAAA,GAAA,EAAA7F,EAAA,EAAA5C,EAAA,EAAA4C,EAAA,EAAA,GAAAzC,MAAAgI,OAAA,MAAAC,eAAA,UAGA,CACA,GAAArI,IAAA8J,EAAA,GAAApB,EAAA,IAAA,CACA7J,MAAAgL,UAAAxK,EAAAU,KAAAC,EAAA0I,EAAA,GAAA,EAAA5F,EAAA,EAAA,EAAA,EAAAA,EAAA,GAAA1C,MAAAgI,OAAA,MAAAC,eAAA,UAKAxJ,KAAAyH,cAAA,WAEA,MAAAzH,KAAAgL,WACAhL,KAAAgL,UAAAjI,SACA/C,KAAAgL,UAAA,MAKAhL,KAAAkL,aAAA,WAEA,GAAA,UAAAlL,KAAAc,MAAA,MAAAd,KAAAsF,kBAAA,GACA,CACAtF,KAAA4K,YAAA/I,QAAA,EAAA,EAEA,IAAAsJ,GAAAnL,KAAA4K,YAAAlK,MAAAE,MACA,KAAAc,EAAA1B,KAAA4K,YAAAjK,KAAAwK,EAAAzJ,EAAAA,IACA1B,KAAA4K,YAAAlK,MAAAgB,GAAAqB,QACA,KAAArB,EAAA1B,KAAA4K,YAAAjK,KAAAwK,EAAAzJ,EAAAA,IACA1B,KAAA4K,YAAAlK,MAAAmE,KAEA7E,MAAA0G,gBAAA1G,KAAA6K,YAAA,EAAA7K,KAAA4K,YAAAlK,SAMAV,KAAAoL,SAAA,IAMApL,KAAA0H,cAAA,WAEA1H,KAAAkL,eACAlL,KAAAsJ,YAAArG,MACA,KAAA,GAAAvB,GAAA,EAAAA,EAAA1B,KAAAsF,kBAAA1E,OAAAc,IACA,CACA,GAAA2J,GAAArL,KAAA2J,YAAAjI,EACA,OAAA1B,KAAAsF,kBAAA5D,KAEA1B,KAAAsF,kBAAA5D,GAAAyB,UAAAlB,gBAAAoJ,EAAA,GAAAA,EAAA,GAAArL,KAAAoL,UACApL,KAAAsF,kBAAA5D,GAAAyB,UAAAH,UASAhD,KAAA2H,0BAAA,SAAAT,EAAAC,EAAAtH,EAAAC,EAAAC,GAEAC,KAAAsJ,YAAArG,MACA,IACAvB,GAAA2J,EADAC,EAAAtL,KAAA6I,qBAAA3B,EAAAC,EAAAtH,EAAAC,EAAAC,EAGA,IAAA,WAAAC,KAAA8D,gBACA,IAAApC,EAAA,EAAAA,GAAA1B,KAAAmE,SAAAzC,IAEA2J,EAAArL,KAAA2J,YAAAjI,GACA,MAAA4J,EAAA5J,KACA4J,EAAA5J,IAAAwF,EAAA5B,kBAAA6B,IAEAnH,KAAAsJ,YAAAtG,OACAhD,KAAAsJ,YAAAzH,QAAAwJ,EAAA,GAAAA,EAAA,IACArL,KAAAsJ,YAAA3H,UACAuF,EAAA5B,kBAAA6B,GAAAnE,OACAkE,EAAA5B,kBAAA6B,GAAAhE,UAAAxB,YAIA2J,EAAA5J,GAAAyB,UAAAlB,gBAAAoJ,EAAA,GAAAA,EAAA,GAAArL,KAAAoL,UACAE,EAAA5J,GAAAsB,QAKA,IAAA,UAAAhD,KAAA8D,gBACA,CACA,GAAA,WAAA9D,KAAAkE,SACA,MAEA,KAAAxC,EAAA,EAAAA,EAAA1B,KAAAmE,SAAAzC,IACA,MAAA1B,KAAAsF,kBAAA5D,IACA1B,KAAAsF,kBAAA5D,GAAAsB,MAEA,IAAAhD,MAAAkH,EAGA,IADA,GAAAqE,GAAApE,EACAoE,EAAA,EAAAvL,KAAAmE,UAAA,MAAAnE,KAAAsF,kBAAAiG,EAAA,IAEAF,EAAArL,KAAA2J,YAAA4B,GACAvL,KAAAsF,kBAAAiG,EAAA,GAAApI,UAAAlB,gBAAAoJ,EAAA,GAAAA,EAAA,GAAArL,KAAAoL,UACAG,IAKA,MAAAD,EAAAtL,KAAAmE,WACAmH,EAAAtL,KAAAmE,UAAAkF","file":"drag-and-drop.min.js","sourcesContent":["/*\n  Une action correspond à ce qui peut se passer un draggable objet\n  si on le lache. Elle indique où l'objet doit être envoyé (dstCont est\n  l'id du container destination, et dstPos et l'indice de la position\n  dans le container).\n  dropType peut valoir : \"replace\" ou \"insert\"\n  et expliquer comment l'objet doit être mis dans le container destination\n  (dans le cas où l'action est bien réalisée).\n*/\nfunction _action(dstCont, dstPos, dropType)\n{\n   this.dstCont = dstCont;\n   this.dstPos = dstPos;\n   this.dropType = dropType;  \n\n   this.sameAs = function(other)\n   {\n      return this.dstCont == other.dstCont && this.dstPos == other.dstPos && this.dropType == other.dropType;\n   };\n}\n\nfunction action(dstCont, dstPos, dropType) \n{ \n   return new _action(dstCont, dstPos, dropType); \n}\n\n","/*\n  Component : Permet de manipuler un objet graphique composé de plusieurs\n  petits objets Raphael, donnés dans le tableau arrayElems. Ces sous-objets\n  doivent être donnés en coordonnées relatives : si un objet du tableau est\n  un objet Raphael centré en (10,20) alors il apparaitra en (cx+10,cy+20),\n  (cx,cy) étant le centre du super-objet.\n  Notamment, on peut faire:\n  - des déplacements, ce qui déplace ensemble tous les sous-objets.\n  - du drag&drop, en propageant les fonctions callbacks à tous  les\n    sous-objets, de sorte que lorsqu'un des sous-objets et déplacés,\n    tous les autres subissent le même déplacement. Ainsi on voit\n    tous les objets bouger ensemble, comme si c'était un seul gros objet.\n*/\nfunction _component(cx, cy, arrayElems, paper)\n{\n   var that = this;\n\n\n   this.cx = cx;\n   this.cy = cy;\n   this.elems = arrayElems;\n   this.paper = paper;\n\n   this.nbEl = this.elems.length;\n\n\tfor(var iEl = 0; iEl < this.nbEl; iEl++)\n\t{\n\t\tif(this.elems[iEl].type == 'text')\n\t\t{\n\t\t\tvar bb = this.elems[iEl].getBBox();\n\t\t\tthis.elems.push(paper.rect(bb.x,bb.y,bb.width,bb.height).attr('fill','red').attr('opacity',0));\n\t\t}\n\t}\n\n\n        /*\n\t  Les sous-objets subissent des déplacements en utilisant la chaine de déplacements\n          Raphael (c'est une chaine de caractêres qui concatêne toutes les transformations\n          à appliquer à l'objet). Pour ne pas rendre cette chaine tres longue, on se souvient\n          de la transformation initiale de l'objet et on applique une translation de (cx,cy).\n        */\n\tthis.oldTransforms = new Array();\n\tfor(var i = 0; i < this.elems.length; i++)\n\t{\n\t\tthis.elems[i].toFront();\n\t\tthis.oldTransforms[i] = this.elems[i].transform();\n\t\tthis.elems[i].transform('t' + this.cx + ',' + this.cy + this.oldTransforms[i]);\n\t}\n\n\n   this.placeAt = function(cx,cy)\n   {\n      this.cx = cx;\n      this.cy = cy;\n\n      for (var i = 0; i < this.elems.length; i++)\n         this.elems[i].transform('t' + this.cx + ',' + this.cy + this.oldTransforms[i]);\n      return this;\n   };\n\n   var animation = function(i, time) \n   {\n      return Raphael.animation({'transform' : 't' + that.cx + ',' + that.cy + that.oldTransforms[i]}, time, '');\n   };\n\n   this.placeAtWithAnim = function(cx,cy,time)\n   {\n      this.cx = cx;\n      this.cy = cy;\n\n      for (var i = 0; i < this.elems.length; i++)\n         this.elems[i].animate(animation(i,time));\n      return this;      \n   };\n\n   this.move = function(dx,dy) { this.placeAt(this.cx+dx,this.cy+dy); };\n   this.moveWithAnim = function(dx,dy,time) { this.placeAt(this.cx+dx,this.cy+dy,time); };\n\n\n        /*\n\t  On retransmet aux éléments fils les callbacks drag&drop\n          pour wraper le système de drag&drop de Raphael js.\n\t  Lorsqu'on écrit \"this\" dans un de ces callbacks,\n\t  il faut voir que cela correspond au super objet.\n\t  (voir la définition de start, move et up dans\n\t  dragAndDropSystem.js)\n        */\n\tthis.drag = function(moveDrag, startDrag, upDrag)\n\t{\n\t\tthat.hasReallyMoved = false;\n\t\tthis.startDrag = startDrag;\n\t\tthis.moveDrag = moveDrag;\n\t\tthis.upDrag = upDrag;\n\n      for (var i = 0; i < this.elems.length; i++)\n         this.elems[i].drag(function(dx,dy){that.moveDrag(dx,dy);}, \n                            function(){that.startDrag();}, \n                            function(){that.upDrag();});\n      return this;\n   };\n\n\n        /*\n\t  Recrée un super-objet identique, remis en position (cx,cy), dont\n          les sous-objets sont obtenus avec le .clone() de Raphael.\n\t*/\n\tthis.clone = function()\n\t{\n\t\tvar newArr = new Array();\n\t\tfor(var i = 0; i < this.nbEl; i++)\t\n\t\t{\n\t\t\tnewArr[i] = this.elems[i].clone();\n         if (this.oldTransforms[i] != undefined)\n         {\n            newArr[i] = newArr[i].attr('transform',this.oldTransforms[i]);\n         }\n\t\t}\n\t\treturn new _component(this.cx,this.cy,newArr,this.paper);\t\n\t};\n\n   this.remove = function()\n   {\n      for (var i = 0; i < this.elems.length; i++)  \n         this.elems[i].remove();    \n   };\n\n   this.toFront = function()\n   {\n      for (var i = 0; i < this.elems.length; i++)\n         this.elems[i].toFront();\n      \n   };\n   \n   this.show = function()\n   {\n      for (var i =0; i < this.nbEl; i++)  \n         if (!this.elems[i].attr('transparent')) { // TODO: save original opacity attribute\n            this.elems[i].attr('opacity','1');\n         }\n   };\n\n   this.hide = function()\n   {\n      for (var i = 0; i < this.nbEl; i++) \n         this.elems[i].attr('opacity','0');  \n   };\n\n   this.halfHide = function()\n   {\n      for (var i = 0; i < this.nbEl; i++) \n         if (!this.elems[i].attr('transparent')) {\n            this.elems[i].attr('opacity','0.3');\n         }\n   };\n}\n\nfunction component(cx, cy, arrayElems,paper){ return new _component(cx, cy, arrayElems,paper); }\n\n\n\n\n\n","\n///Container\n/*\n  Un container est un ensemble de cases (aliginées verticalement ou horizontalement). On peut lui donner\n  beaucoup de paramêtre pour spécifier son comportement.\n  direction : doit valoir \"vertical\" ou \"horizontal\"\n  align : dans le cas vertical, peut valoir \"left\" pour indiquer que la première case est à gauche, ou \"right\"\n          pour indiquer que la première case est à droite. Dans le cas vertical, peut valoir \"top\" ou \"bottom\".\n  cx, cy : donne le centre de la case la plus haute (pour le vertical) ou la plus a gauche (pour le cas horizontal)\n  dropMode :\n     - \"replace\" : lorsqu'un objet est laché sur une case, la case détruit son éventuel objet courant pour recevoir le nouveau.\n     - \"insert\"  : lorsqu'un objet est laché sur la case, l'objet actuel de la case (s'il y en a un) est décalé vers la droite,\n                   entrainant éventuellement un autre décalage et ainsi de suite... il peut y avoir une suppression\n                   si le dernier objet se fait éjecter du container.\n     - \"insert-replace\" : lorsqu'on lache l'objet, s'il est vers le début de la case, alors on a un comportement insert,\n                          sinon un comportement replace.\n     - \"insertBefore\" : comme insert, mais la zone de drop est plus du coté du début de la case, donc ca marche mieux\n                        avec dragDisplayMode=\"marker\".\n  dragDisplayMode : peut valoir \"preview\" (pour voir le placeholder avec des tirés jaune)\n                    ou \"marker\" (pour voir le trait rouge).\n  placeBackgroundArray : définit le background que l'on met à chaque case (juste pour faire joli).\n  type : peut valoir \"list\", pour un container classique, ou \"source\" le container peut recréer des objets\n         quand on lui prend le sien.\n  sourceElemArray : Utile seulement dans le cas type=\"source\", définit l'objet source à dupliquer.\n*/\nvar _container = function(dragAndDropSystem,ident,cx, cy, nbPlaces, widthPlace, heightPlace, direction, align, dropMode, dragDisplayMode,\n                   placeBackgroundArray, type, sourceElemArray, places)\n{\n   \"use strict\";\n   this.dragAndDropSystem = dragAndDropSystem;\n   this.ident = ident;\n   this.cx = cx;\n   this.cy = cy;\n   this.nbPlaces = nbPlaces;\n   this.widthPlace = widthPlace;\n   this.heightPlace = heightPlace;\n   this.direction = direction;\n   this.align = align;\n   this.dropMode = dropMode;\n   this.dragDisplayMode = dragDisplayMode;\n   this.type = type;\n   this.places = places;\n\n   this.placeHolder = component(0,0,\n      [dragAndDropSystem.paper.rect(-widthPlace/2,-heightPlace/2,widthPlace,heightPlace)\n         .attr({'stroke' : 'yellow', 'stroke-width' : '2', 'stroke-dasharray': '-'})], this.dragAndDropSystem.paper);\n   this.placeHolder.hide();\n   \n   this.sourceElemArray = sourceElemArray;\n\n//sanityCheck\n   this.sanityCheck = function()\n   {\n      if (direction != 'vertical' && direction != 'horizontal')\n         alert('direction should be \\'vertical\\' or \\'horizontal\\'!');\n\n      if (direction == 'vertical')\n         if (align != 'top' && align != 'bottom')\n            alert('Since direction is vertical, align should be \\'top\\' or \\'bottom\\'');\n      if (direction == 'horizontal')\n         if (align != 'left' && align != 'right')\n            alert('Since direction is horizontal, align should be \\'left\\' or \\'right\\'');\n\n      if (dropMode != 'replace' && dropMode != 'insert-replace' && dropMode != 'insert' && dropMode != 'insertBefore')\n         alert('dropMode should be \\'replace\\' or \\'insert\\' or \\'insert-replace\\' or \\'insertBefore\\'');\n\n      if (dragDisplayMode != 'preview' && dragDisplayMode != 'marker')\n         alert('dragDisplayMode should be \\'preview\\' or \\'marker\\' ');\n\n      if (type != 'list' && type != 'source')\n         alert('type should be \\'list\\' or \\'source\\'');\n   };\n   this.sanityCheck();\n\n//utils\n\n   /*\n     Fonction utiliraire : retourne les coordonnées du centre de la\n     case à l'indice iPlace.\n   */\n   this.placeCenter = function(iPlace)\n   {\n      var w = this.widthPlace, h = this.heightPlace;\n      if (this.places != undefined) {\n         return this.places[iPlace];\n      }\n      if (direction == 'horizontal')\n         if (align == 'left')\n            return [this.cx + ((2*iPlace + 1 - this.nbPlaces)*w)/2, this.cy];\n         else\n            return [this.cx + ((this.nbPlaces - 2*iPlace - 1)*w)/2, this.cy];\n      else\n         if (align == 'top')\n            return [this.cx, this.cy + ((2*iPlace + 1 - this.nbPlaces)*h)/2];\n         else\n            return [this.cx, this.cy + ((this.nbPlaces - 2*iPlace - 1)*h)/2]; \n   };\n\n   /*\n     Retourne l'id de la case contenant les coordonnées (x,y)\n   */\n   this.placeId = function(x,y) // return -1 if not contained in a place\n   {\n      for (var iPlace = 0; iPlace < this.nbPlaces; iPlace++)\n      {\n         var c = this.placeCenter(iPlace);\n         var w = this.widthPlace, h = this.heightPlace;\n         if (x>=c[0]-w/2 && x<=c[0]+w/2 && y>=c[1]-h/2 && y<=c[1]+h/2) \n            return iPlace;\n      }\n      return -1;\n   };\n\n   this.isInContainer = function(x,y){return this.placeId(x,y) != -1;};\n\n   // If the point (x,y) is in place i, return a real number between 0 and 1\n   // to give its relative position in the place. For example, a value of \n   // 0.1 means that the point is near from the common border of places i and i-1,\n   // and a value of 0.5 indicates a position in the middle of the place i. \n   this.ratioPositionInPlace = function(x,y) \n   {\n      var c0 = this.placeCenter(0), c1 = this.placeCenter(1);\n      var c0p = [x - c0[0], y - c0[1]];\n      var c0c1 = [c1[0] - c0[0], c1[1] - c0[1]];\n      var prodScal = c0p[0]*c0c1[0] + c0p[1]*c0c1[1];\n      var posAbs = parseFloat(prodScal) / parseFloat(c0c1[0]*c0c1[0] + c0c1[1]*c0c1[1]) + 0.5;     \n      return posAbs - this.placeId(x,y);     \n   };\n\n   /*\n     Renvoie l'action correspondant à ce qu'il faudrait faire si un objet\n     l'objet est laché en position (x,y).\n    */\n   this.getCorrespondingAction = function(el,x,y)\n   {\n      var pos = this.placeId(x,y);\n      var ratio = this.ratioPositionInPlace(x,y);\n      if (pos == -1)\n         return null;\n\n      if (this.dropMode == 'replace')\n         return action(this, pos,'replace'); \n         \n      if (this.dropMode == 'insert-replace')\n      {\n         if (ratio < 0.25)\n            return action(this, pos, 'insert');          \n         if (ratio > 0.75 && pos+1 < this.nbPlaces)\n            return action(this, pos+1, 'insert');\n         return action(this,pos,'replace');\n      }\n   \n      if (this.dropMode == 'insert')\n      {\n         if (ratio < 0.25)\n            return action(this, pos, 'insert');          \n         if (ratio > 0.75 && pos+1 < this.nbPlaces)\n            return action(this, pos+1, 'insert');\n         return null;\n      }\n\n      if (this.dropMode == 'insertBefore')\n      {\n         if (ratio < 0.75)\n            return action(this, pos, 'insert');          \n         else if (ratio > 0.75 && pos+1 < this.nbPlaces)\n            return action(this, pos+1, 'insert');\n         else\n            return null;\n      }\n\n      alert('dropMode ?');\n   };\n\n   /*\n     retourne le tableau correspondant à la liste des objets qu'aurait notre container\n     s'il l'action correspondant aux paramêtres était effectuée.\n   */\n   this.getElementsAfterDrop = function(srcCont, srcPos, dstCont, dstPos, dropType)\n   {\n      var res = [];\n      for (var i = 0; i < this.nbPlaces; i++)\n         res[i] = this.draggableElements[i];\n      res[this.nbPlaces] = null;\n      \n      //removal\n      if (this == srcCont)\n      {\n         if (this.dropMode == 'replace')\n            res[srcPos] = null;\n         else\n         {\n            i = srcPos;\n            while(i+1 <= this.nbPlaces && this.draggableElements[i] != null)\n            {\n               res[i] = res[i+1];\n               i++;\n            }\n         }\n      }\n\n      //push\n      var el = srcCont.draggableElements[srcPos];\n      if (this == dstCont)\n      {\n         if (dropType == 'replace')\n            res[dstPos] = el;\n         else\n         {\n            var end = dstPos;\n            while(end < this.nbPlaces && res[end] != null)\n               end++;\n            for (i = end; i > dstPos; i--)\n               res[i] = res[i-1];\n            res[dstPos] = el; \n         }\n      }\n\n      return res;\n   };\n\n//Draw places\n   this.placeBG = component(0,0,placeBackgroundArray,this.dragAndDropSystem.paper); \n   for (var iPlace = 0; iPlace < this.nbPlaces; iPlace++)\n   {\n      var c = this.placeCenter(iPlace);\n      if (iPlace == 0)\n         this.placeBG.placeAt(c[0],c[1]);\n      else\n         this.placeBG.clone().placeAt(c[0],c[1]);\n   }\n\n//Contents\n\n   this.draggableElements = [];\n   for (var i = 0; i < this.nbMax; i++)\n      this.draggableElements[i] = null;\n\n   this.createDraggable = function(ident, position, shapesArray)\n   {\n      this.dragAndDropSystem.addDraggableElement(ident, this, position, \n         new _component(this.placeCenter(position)[0], this.placeCenter(position)[1], shapesArray,this.dragAndDropSystem.paper) );\n\n      if (this.type == 'source')\n      {\n         this.sourceCompo = this.draggableElements[0].component.clone();\n         this.sourceCompo.move(-10000,-10000);\n         this.sourceIdent = ident;\n         this.sourcePos = position;\n      }\n   };\n\n   if (this.type == 'source')\n   {\n      var cloneArray = [];\n      for (i = 0; i < this.sourceElemArray.length; i++)\n         cloneArray[i] = this.sourceElemArray[i].clone();\n      component(this.cx, this.cy, cloneArray,this.dragAndDropSystem.paper);\n\n      this.createDraggable(this.ident, 0, this.sourceElemArray);  \n   }\n\n\n   this.getObjects = function()\n   {\n      var res = [];\n      for (var i = 0; i < this.nbPlaces; i++)\n         if (this.draggableElements[i] != null)\n            res[i] = this.draggableElements[i].ident;\n         else\n            res[i] = null;\n      return res;\n   };\n\n   this.getElementOver = function(srcEl,x,y)\n   {\n      for (var i = 0; i < this.nbPlaces; i++)\n         if (this.draggableElements[i] != null && this.draggableElements[i] != srcEl)\n         {\n            var el = this.draggableElements[i];\n            if (x >= el.component.cx - this.widthPlace/2 - 1 && x <= el.component.cx + this.widthPlace/2 + 1)\n               if (y >= el.component.cy - this.heightPlace/2 - 1 && y <= el.component.cy + this.heightPlace/2 + 1)\n                  return el;\n               \n         }  \n      return null;\n   };\n\n//Indicator\n   this.indicator = null;\n\n   /*\n     Fait apparaitre le trait rouge ou le carré jaune en pointillé.\n   */\n   this.showIndicator = function(act)\n   {\n      if (this.dragDisplayMode != 'marker')\n         return;     \n\n      var paper = this.dragAndDropSystem.paper;\n      var c = this.placeCenter(act.dstPos);\n      var w = this.widthPlace, h = this.heightPlace;\n      \n      if (act.dropType == 'replace')\n         this.indicator = paper.rect(c[0]-w/2,c[1]-h/2,w,h).attr({'stroke' : 'red', 'stroke-width' : '4'});\n\n      if (act.dropType == 'insert')\n      {\n         var prevC = this.placeCenter(act.dstPos-1);\n         if (this.direction == 'vertical')\n         {\n            var y = (prevC[1] + c[1])/2;\n            this.indicator = paper.rect(c[0]-3*w/4,y,3*w/2,1).attr({'stroke' : 'red', 'stroke-width' : '4'});    \n         }        \n         else\n         {\n            var x = (prevC[0] + c[0])/2;\n            this.indicator = paper.rect(x,c[1]-3*h/4,1,3*h/2).attr({'stroke' : 'red', 'stroke-width' : '4'});\n         }\n      }        \n   };\n\n   this.hideIndicator = function()\n   {\n      if (this.indicator != null)\n         this.indicator.remove();\n      this.indicator = null;     \n   };\n\n// update source\n\nthis.updateSource = function()\n{\n   if (this.type == 'source' && this.draggableElements[0] == null)\n   {\n      this.sourceCompo.placeAt(0,0);\n\n      var newSize = this.sourceCompo.elems.length;\n      for (i = this.sourceCompo.nbEl; i < newSize; i++)\n         this.sourceCompo.elems[i].remove();\n      for (i = this.sourceCompo.nbEl; i < newSize; i++)\n         this.sourceCompo.elems.pop();\n\n      this.createDraggable(this.sourceIdent, 0 ,this.sourceCompo.elems);\n   }\n};\n\n// update views\n\n   this.timeAnim = 100;\n\n   /*\n     Demande de faire un affichage correspondant à l'état actuel\n     du container (et dessinant chacun de ses objets contenus à la bonne place)\n   */\n   this.updateDisplay = function()\n   {\n      this.updateSource();\n      this.placeHolder.hide();\n      for (var i = 0; i < this.draggableElements.length; i++)\n      {\n         var center = this.placeCenter(i);\n         if (this.draggableElements[i] != null)\n         {\n            this.draggableElements[i].component.placeAtWithAnim(center[0], center[1], this.timeAnim);\n            this.draggableElements[i].component.show();\n         }\n      }\n   };\n\n   /*\n     Demande de montrer un affichage correspondant à l'état dans lequel deviendrait\n     le container si on faisait la manipulation passée en paramêtre.\n   */\n   this.updateIntermediateDisplay = function(srcCont, srcPos, dstCont, dstPos, dropType)\n   {\n      this.placeHolder.hide();\n      var intermed = this.getElementsAfterDrop(srcCont, srcPos, dstCont, dstPos, dropType);\n      var i, center;\n\n      if (this.dragDisplayMode == 'preview')       \n         for (i = 0; i <= this.nbPlaces; i++)\n         {\n            center = this.placeCenter(i);\n            if (intermed[i] != null)\n               if (intermed[i] == srcCont.draggableElements[srcPos])  \n               {\n                  this.placeHolder.show();\n                  this.placeHolder.placeAt(center[0], center[1]);\n                  this.placeHolder.toFront();\n                  srcCont.draggableElements[srcPos].show();\n                  srcCont.draggableElements[srcPos].component.toFront();\n               }\n               else\n               {\n                  intermed[i].component.placeAtWithAnim(center[0], center[1], this.timeAnim);\n                  intermed[i].show();\n               }           \n         }  \n      \n\n      if (this.dragDisplayMode == 'marker')\n      {\n         if (this.dropMode == 'replace')\n            return;\n\n         for (i = 0; i < this.nbPlaces; i++)\n            if (this.draggableElements[i] != null)\n               this.draggableElements[i].show();\n\n         if (this == srcCont)\n         {\n            var iPlaceIns = srcPos;\n            while(iPlaceIns+1 < this.nbPlaces && this.draggableElements[iPlaceIns+1] != null)\n            {\n               center = this.placeCenter(iPlaceIns);\n               this.draggableElements[iPlaceIns+1].component.placeAtWithAnim(center[0],center[1],this.timeAnim);\n               iPlaceIns++;\n            }\n         }\n      }\n\n      if (intermed[this.nbPlaces] != null)\n         intermed[this.nbPlaces].cross();\n   };\n}\n\n// Constructeur \"intelligent\"\n\nfunction container(_params)\n{\n   var params = _params;\n\n   if (params.dragAndDropSystem == undefined)\n      alert('no dragAndDropSystem is specified');\n   if (params.ident == undefined)\n      params.ident = '';\n   if (params.type == undefined)\n      params.type = 'list';\n   if (params.type != 'source' && params.type != 'list')\n      alert('type should be \\'source\\' or \\'list\\'');\n\n   if (params.cx == undefined || params.cy == undefined)\n      alert('cx and cy are not specified');\n\n   if (params.widthPlace == undefined)\n      params.widthPlace = 40;\n   if (params.heightPlace == undefined)\n      params.heightPlace = 40;\n\n   if (params.align != undefined)\n   {\n      if (params.align != 'top' && params.align != 'bottom' && params.align != 'left' && params.align != 'right')\n         alert('align should be \\'top\\' or \\'bottom\\' or \\'left\\' or \\'right\\'');\n   \n      if (params.align == 'top' || params.align == 'bottom')\n         params.direction = 'vertical';\n      else\n         params.direction = 'horizontal';\n   }\n   else\n   {\n      if (params.direction == undefined)\n      {\n         params.direction = 'horizontal';\n         params.align = 'left';\n      }\n      else\n      {\n         if (params.direction == 'vertical')\n            params.align = 'top';\n         else if (params.direction == 'horizontal')\n            params.align = 'left';\n         else\n            alert('direction should be \\'vertical\\' or \\'horizontal\\' ');\n      }\n   }\n\n   if (params.dragDisplayMode == undefined)\n      params.dragDisplayMode = 'preview';\n   else if (params.dragDisplayMode != 'preview' && params.dragDisplayMode != 'marker')\n      alert('dragDisplayMode should be \\'preview\\' or \\'marker\\' ');\n\n   if (params.placeBackgroundArray == undefined)\n   {\n      var paper = params.dragAndDropSystem.paper;\n      var w = params.widthPlace, h = params.heightPlace;\n      params.placeBackgroundArray = [paper.rect(-w/2,-h/2,w,h).attr('fill','blue')];            \n   }\n\n//Source\n   if (params.type == 'source')\n   {\n      if (params.dropMode == undefined)\n         params.dropMode = 'replace';  \n      \n      params.nbPlaces = 1;\n\n      if (params.sourceElemArray == undefined)\n         alert('sourceElemArray should be defined');\n   }\n\n//List   \n   if (params.type == 'list')\n   {\n      if (params.dropMode == undefined)\n         params.dropMode = 'insert';               \n\n      if (params.nbPlaces == undefined)\n         params.nbPlaces = 5;\n   }     \n\n   return new _container(\n      params.dragAndDropSystem, params.ident,\n      params.cx, params.cy, params.nbPlaces, params.widthPlace, params.heightPlace,\n      params.direction, params.align, \n      params.dropMode, params.dragDisplayMode,\n      params.placeBackgroundArray, params.type, params.sourceElemArray, params.places);\n}\n\n","///DragAndDropSystem\n\n/*\n  paper: paperRaphael, //le canvas Raphael dans lequel on dessine\n  keepLastGoodAction : // ou false, indique si on garde la dernière action valide comme référence. \n                       // (par defaut à true)\nCallbacks :\t\t      \n   canBeTaken(containerID, position) : retourne si l'objet peut être attrappé par l'utilisateur\n\n   actionIfDropped(srcContainerID, srcPos, dstContainerID, dstPos, dropType) :\n       dropType: “insert” ou “replace”\n       retourne :\n       - true si l'objet source peut être inséré à cette destination\n       - false si on refuse de l’insérer\n       - un objet action(otherDstContId, otherDstPos, otherDropType) pour envoyer l’objet source ailleurs\n\n   drop(srcContainerID, srcPos, dstContainerID, dstPos, dropType) :\n      dropType: “insert” ou “replace”\n      appelé lorsque l'on vient de dropper l'objet\n\n   actionIfEjected(refElement, previousContainerId, previousPos) :\n      appelée lorsqu’un objet est éjecté, par exemple parce qu’il vient d’être\n      remplacé par un autre ou bien parce qu’il était en dernière position d’un\n      conteneur et qu’une insertion le fait sortir.\n      retourne : \n      - null si l’objet éjecté doit être détruit.\n      - un objet action(dstContId, dstPos, dropType) pour envoyer l’objet ailleurs\n          (l’action est alors traitée, entrainant notamment un appel a drop).\n\n   ejected(refEl, previousCont, previousPos) : indique qu'il y a eu une ejection\n*/\nfunction _DragAndDropSystem(paper)\n{  \n   \"use strict\";\n   this.paper = paper;\n\n   this.keepLastGoodAction = true;\n\n//Containers\n   this.containers = new Array();   \n   this.addContainer = function(params) \n   {\n      params.dragAndDropSystem = this;\n      this.containers.push(container(params) );\n      return this.containers[this.containers.length-1];\n   };\n\n   this.removeContainer = function(cont)\n   {\n      for (var i = 0; i < this.containers.length; i++) {\n         if (this.containers[i] == cont)\n         {\n            this.containers[i] = this.containers[this.containers.length-1];\n            this.containers.pop();\n         }\n      }\n   };\n\n   // Create a temporary container, useful for ejection \n   this.addContainer({\n      ident : 'temporaryContainer', \n      cx : -1000, cy : -1000, nbPlaces : 1, widthPlace : 10, heigthPlace : 10,\n      direction : 'vertical', align : 'top',\n      dropMode : 'replace', dragDiplayMode : 'marker',\n      placeBackgroundArray : [],\n      type : 'list'});\n\n//Draggable elements\n   this.addDraggableElement = function(ident,container, position,comp)\n   {\n      var dragEl = new _draggableElement(ident, container, position,comp);\n      comp.draggableElement = dragEl;\n      container.draggableElements[position] = dragEl;\n\n      var that = this;\n      var start = function()\n      {\n         if (this.hasReallyMoved) {\n            this.upDrag();\n         }\n         if (!that.canBeTaken(this.draggableElement.container.ident, this.draggableElement.position))\n            return;\n         this.startcx = this.cx;\n         this.startcy = this.cy; \n         this.hasReallyMoved = false;\n         this.toFront();\n      };\n\n      var move = function(dx,dy)\n      {\n         if (isNaN(dx) || isNaN(dy)) // Très important : peu buggué sur certains navigateur sinon !\n            return;\n\n         if (!that.canBeTaken(this.draggableElement.container.ident, this.draggableElement.position))\n            return;\n\n         this.placeAt(this.startcx + dx, this.startcy + dy);\n\n\t // tant que l'objet n'a pas vraiment bougé, on ne le detache pas vraiment\n\t // sinon ça ferait un effet visuel pas très agréable. \n         if (Math.abs(this.cx - this.startcx) > 5 || Math.abs(this.cy - this.startcy) > 5)\n         {\n            this.hasReallyMoved = true; \n            that.hasBeenTaken(dragEl);\n         }\n         if (this.hasReallyMoved)\n            that.hasBeenMoved(dragEl,this.cx,this.cy);\n      }\n\n      var up = function()\n      {\n         if (!that.canBeTaken(this.draggableElement.container.ident, this.draggableElement.position))\n            return;\n\n         if (!this.hasReallyMoved)  \n         {\n            this.placeAt(this.startcx, this.startcy);\n            return;\n         }\n\t\t        this.hasReallyMoved = false;\n\n         that.hasBeenDropped(dragEl,this.cx,this.cy);\n      }\n      \n      comp.drag(move,start,up); // donne au component ses callbacks, qu'il retransmet\n                                // à ses sous-objets (voir component.js)\n\n      return dragEl;\n   };\n\n   this.removeDraggableElement = function(el)\n   {\n      for (var i = 0; i < this.draggableElements.length; i++)\n         if (this.draggableElements[i] == el)\n         {\n            this.draggableElements[i] = this.draggableElements[this.draggableElements.length-1];\n            this.draggableElements.pop();\n         }\n   };\n\n   this.getObjects = function(containerId)\n   {\n      for (var iCont = 0; iCont < this.containers.length; iCont++)\n         if (this.containers[iCont].ident == containerId)\n            return this.containers[iCont].getObjects();\n   };\n\n   this.insertObject = function(containerId, pos, elem)\n   {\n      for (var iCont = 0; iCont < this.containers.length; iCont++)\n         if (this.containers[iCont].ident == containerId)\n            this.containers[iCont].createDraggable(elem.ident, pos, elem.elements);    \n   };\n\n   this.insertObjects = function(containerId, pos, elems)\n   {\n      // optimized version of insertObject applied to each of the elems\n      for (var iCont = 0; iCont < this.containers.length; iCont++) {\n         if (this.containers[iCont].ident == containerId) {\n            var cont = this.containers[iCont];\n            for (var i = 0; i < elems.length; i++) {\n               var elem = elems[i];\n               if (elem != null) {\n                  cont.createDraggable(elem.ident, pos+i, elem.elements);    \n               }\n            }\n         }\n      }\n   };\n\n\n   this.removeObject = function(containerId, pos)\n   {\n      for (var iCont = 0; iCont < this.containers.length; iCont++)\n         if (this.containers[iCont].ident == containerId)\n         {\n            var el = this.containers[iCont].draggableElements[pos];\n            this.containers[iCont].draggableElements[pos] = null;\n            el.remove();\n         }        \n   };\n\n   this.removeAllObjects = function(containerId) \n   {\n      // optimized version of: getObjects followed by removeObject on each of them\n      for (var iCont = 0; iCont < this.containers.length; iCont++) {\n         if (this.containers[iCont].ident == containerId) {\n            var elems = this.containers[iCont].draggableElements;\n            for (var i = 0; i < elems.length; i++) {\n               var el = elems[i];\n               if (el != null) {\n                  elems[i] = null;\n                  el.remove();\n               }\n            }\n         }\n      }\n   }\n\n\n   //the user uses identifier instead of a reference for containers\n   this.userActionToAction = function(act)\n   {\n      for (var iCont = 0; iCont < this.containers.length; iCont++)\n         if (this.containers[iCont].ident == act.dstCont)\n            return action(this.containers[iCont], act.dstPos, act.dropType);\n\n      return action(null , act.dstPos, act.dropType);\n   };\n\n   // return the action object corresponding to what to do if el is dropped here\n   this.getCorrespondingAction = function(el,cx,cy)\n   {\n      var srcCont = el.container, srcPos = el.position;\n      //We test if one containter can recieve\n      for (var iCont = 0; iCont < this.containers.length; iCont++)\n      {\n         var dstCont = this.containers[iCont];\n         if (dstCont.isInContainer(cx,cy))\n         {\n            var act = dstCont.getCorrespondingAction(el,cx,cy);\n            if (act == null)\n               continue;\n            var actUser = this.actionIfDropped(srcCont.ident, srcPos, act.dstCont.ident, act.dstPos, act.dropType);\n            if (actUser == true)\n               return act;\n            if (actUser != false)\n               return this.userActionToAction(actUser);\n         }\n      }\n\n      //Here, no container can recieve, we thus call actionIfDropped for an empty dst.\n      var actUser = this.actionIfDropped(srcCont.ident, srcPos, null,null,'insert');\n      if (actUser == true)\n         return action(null,null,'insert');\n      if (actUser != false)\n         return this.userActionToAction(actUser);\n\n      //Default behaviour\n      if (this.keepLastGoodAction && this.lastDisplayedAction != null)\n         return this.lastDisplayedAction;\n\n      return action(srcCont, srcPos, srcCont.dropMode);     \n   };\n\n   this.hideIndicators = function() \n   {\n      for (var iCont = 0; iCont < this.containers.length; iCont++)\n         this.containers[iCont].hideIndicator();\n   };\n\n   this.updateDisplay = function()\n   {\n      for (var iCont = 0; iCont < this.containers.length; iCont++)\n         this.containers[iCont].updateDisplay();         \n   };\n\n   this.updateIntermediateDisplay = function(srcCont, srcPos, dstCont, dstPos, dropType)\n   {\n      for (var iCont = 0; iCont < this.containers.length; iCont++)\n         this.containers[iCont].updateIntermediateDisplay(srcCont, srcPos, dstCont, dstPos, dropType);        \n   };\n   \n   this.getElementOver = function(srcEl,x,y)\n   {\n      for (var iCont = 0; iCont < this.containers.length; iCont++)\n      {\n         var el = this.containers[iCont].getElementOver(srcEl,x,y);\n         if (el != null)\n            return el;\n      }     \n      return null;\n   };\n\n// Inner Signals\n   this.hasBeenTaken = function(el)\n   {\n   };\n\n   this.lastDisplayedAction = null;\n   this.lastOver = -1;\n   this.hasBeenMoved = function(el,cx,cy)\n   {\n      var action = this.getCorrespondingAction(el,cx,cy);\n\n      var elOver = this.getElementOver(el,cx,cy); \n\n      if (this.lastOver !== elOver)\n      {\n         this.lastOver = elOver;\n         if (this.lastOver != null)\n            this.over(el.container.ident, el.position, elOver.container.ident, elOver.position);\n         else\n            this.over(el.container.ident, el.position, null, 0);     \n      }\n\n      if (this.lastDisplayedAction == null || !action.sameAs(this.lastDisplayedAction))\n      {\n         this.lastDisplayedAction = action;\n         this.hideIndicators();\n         if (action.dstCont != null)\n         {\n            action.dstCont.showIndicator(action);\n            el.component.toFront();\n         }\n         this.updateIntermediateDisplay(el.container, el.position, action.dstCont, action.dstPos, action.dropType);\n      }\n   };\n\n   this.hasBeenDropped = function(el,cx,cy)\n   {\n      this.hideIndicators();\n      var action = this.getCorrespondingAction(el,cx,cy);\n\n      var srcCont = el.container, srcPos = el.position;\n      this.processDeplacement(srcCont, srcPos, action.dstCont, action.dstPos, action.dropType);\n\n      this.lastDisplayedAction = null;\n      this.lastOver = -1;\n   };\n\n// Authorization\n\n   this.canBeTaken = function(conteneurId, position) { return true; };\n   this.actionIfDropped = function(srcContId, srcPos, dstContId, dstPos, dropType) { return true; };\n   \n// User signals\n\n   this.drop = function(srcContId, srcPos, dstContId, dstPos, dropType) {  };\n   this.over = function(srcContId, srcPos, dstContId, dstPos) {} ;\n   this.actionIfEjected = function(refEl, previousCont, previousPos) {return null; };\n   this.ejected = function(refEl, previousCont, previousPos){};\n\n// Process deplacement\n\n   this.processDeplacement = function(srcCont, srcPos, dstCont, dstPos, dropType)\n   {\n      var newObjects = new Array();\n      for (var iCont = 0; iCont < this.containers.length; iCont++)\n         newObjects[iCont] = this.containers[iCont].getElementsAfterDrop(srcCont, srcPos, dstCont, dstPos, dropType);\n      \n      var ejected = null;\n\n      //If an element is deplaced after the end, it will be ejected\n      for (var iCont = 0; iCont < this.containers.length; iCont++)\n         if (newObjects[iCont][this.containers[iCont].nbPlaces] != null)\n         {\n            var elEjected = newObjects[iCont][this.containers[iCont].nbPlaces];\n            var previousCont = this.containers[iCont];\n            ejected = {'refEl' : elEjected, 'previousCont' : previousCont, 'previousPos' : (this.containers[iCont].nbPlaces-1)};     \n         }  \n\n      //If an element was overwritten, it will be ejected\n      var iDstCont = -1;\n      for (var iCont = 0; iCont < this.containers.length; iCont++)\n         if (this.containers[iCont] == dstCont)\n            iDstCont = iCont;\n      if (iDstCont != -1)\n         if (dropType == 'replace' && newObjects[iDstCont][dstPos] != null && dstCont.draggableElements[dstPos] != null)\n            if (newObjects[iDstCont][dstPos] != dstCont.draggableElements[dstPos])\n            {        \n               var elEjected = dstCont.draggableElements[dstPos];\n               var previousCont = this.containers[iDstCont];\n               var previousPos = dstPos;\n               ejected = {'refEl' : elEjected, 'previousCont' : previousCont, 'previousPos' : previousPos};  \n            }\n\n      //If we drop into the void, the element will be ejected\n      if (dstCont == null)\n         ejected = {'refEl' : srcCont.draggableElements[srcPos], 'previousCont' : srcCont, 'previousPos' : srcPos};   \n\n      //copy\n      for (var iCont = 0; iCont < this.containers.length; iCont++)\n      {\n         var cont = this.containers[iCont];\n         for (var iPlace = 0; iPlace < cont.nbPlaces; iPlace++)\n         {\n            cont.draggableElements[iPlace] = newObjects[iCont][iPlace];\n            if (cont.draggableElements[iPlace] != null)\n            {\n               cont.draggableElements[iPlace].container = cont;\n               cont.draggableElements[iPlace].position = iPlace;  \n            }\n         }     \n      }  \n   \n      this.updateDisplay();\n\n      if (dstCont != null)\n         this.drop(srcCont.ident, srcPos, dstCont.ident, dstPos, dropType);      \n      else\n         this.drop(srcCont.ident, srcPos, null);\n      \n      //If needed, we process the ejection\n      if (ejected != null)\n         this.manageEjection(ejected['refEl'], ejected['previousCont'], ejected['previousPos']);\n\n   };\n\n   // Ejection\n\n   this.manageEjection = function(refEl, previousCont, previousPos)\n   {\n      var act = this.actionIfEjected(refEl, previousCont.ident, previousPos);\n      refEl.show();\n      if (act == null)\n         refEl.remove();\n      else\n      {\n         //push in temporary container, little hack\n         act = this.userActionToAction(act);\n         this.containers[0].draggableElements[0] = refEl;\n         refEl.container = this.containers[0];\n         refEl.position = 0;  \n         this.processDeplacement(this.containers[0], 0, act.dstCont, act.dstPos, act.dropType);\n      }\n      \n      this.ejected(refEl, previousCont.ident, previousPos); \n   };\n}\n\n//function DragAndDropSystem(paper){return new _DragAndDropSystem(paper);}\n\nfunction DragAndDropSystem(params)\n{\n   if (params.paper == undefined)\n      alert('paper should be defined');\n   \n   var dragAndDrop = new _DragAndDropSystem(params.paper);\n   \n   if (params.keepLastGoodAction != undefined)\n      dragAndDrop.keepLastGoodAction = params.keepLastGoodAction;\n\n   if (params.canBeTaken != undefined)\n      dragAndDrop.canBeTaken = params.canBeTaken;\n\n   if (params.actionIfDropped != undefined)\n      dragAndDrop.actionIfDropped = params.actionIfDropped;\n\n   if (params.drop != undefined)\n      dragAndDrop.drop = params.drop;\n\n   if (params.actionIfEjected != undefined)\n      dragAndDrop.actionIfEjected = params.actionIfEjected;\n\n   if (params.ejected != undefined)\n      dragAndDrop.ejected = params.ejected;\n\n   if (params.over != undefined)\n      dragAndDrop.over = params.over;\n\n   return dragAndDrop;\n};","\n///DraggableElement\n/*\n  Un draggable element, correspond à un objet graphique (voir component.js)\n  capable de changé de case de container.\n*/\nfunction _draggableElement(ident, container, position, component)\n{\n   this.ident = ident;\n   this.container = container;\n   this.position = position;\n   this.component = component;\n\n\n    this.crossShape = null; //symbole de la croix en cas d'éjection\n\n   this.remove = function()\n   {\n      if (this.crossShape != null)\n         this.crossShape.remove();\n      this.crossShape = null;\n\n      this.component.remove();   \n   };\n\n   this.cross = function()\n   {\n      if (this.crossShape != null)\n         this.crossShape.remove();\n\n      this.component.halfHide();\n      \n   };\n\n   this.show = function()\n   {\n      if (this.crossShape != null)\n         this.crossShape.remove();\n      this.crossShape = null;\n\n      this.component.show();\n   };\n\n   this.hide = function()\n   {\n      if (this.crossShape != null)\n         this.crossShape.remove();\n      this.crossShape = null;\n\n      this.component.hide();\n   };\n}\n\n\n\n"],"sourceRoot":"/source/"}